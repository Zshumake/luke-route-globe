<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåç Luke's Route Globe v2.1 DEBUG</title>
    
    <!-- Cesium.js -->
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: white;
            overflow: hidden;
        }

        .main-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        /* Sidebar for routes */
        .sidebar {
            width: 350px;
            background: linear-gradient(180deg, #16213e 0%, #0f172a 100%);
            border-right: 2px solid #334155;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 20px rgba(0,0,0,0.3);
            height: 100vh;
            overflow-y: auto; /* Enable vertical scrolling */
            overflow-x: hidden; /* Hide horizontal overflow */
        }
        
        /* Custom scrollbar for sidebar */
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        .sidebar::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 4px;
        }
        .sidebar::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #3b82f6 0%, #1d4ed8 100%);
            border-radius: 4px;
        }
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #60a5fa 0%, #2563eb 100%);
        }

        .sidebar-header {
            padding: 20px;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            text-align: center;
        }

        .sidebar-header h1 {
            font-size: 1.8em;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .sidebar-header p {
            font-size: 0.9em;
            opacity: 0.9;
        }

        /* Tab Navigation System */
        .tab-navigation {
            display: flex;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-top: 1px solid #334155;
            margin: 0 -20px;
            padding: 0;
        }

        .tab-btn {
            flex: 1;
            padding: 15px 10px;
            border: none;
            background: transparent;
            color: #94a3b8;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }

        .tab-btn:hover {
            background: rgba(59, 130, 246, 0.1);
            color: #e2e8f0;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border-bottom-color: #60a5fa;
        }

        /* Tab Content Areas */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Specific styling for My Routes tab to maintain existing layout */
        #lukes-routes {
            padding: 0;
        }

        /* Styling for Discover Routes tab */
        #discover-routes {
            padding: 20px;
            padding-top: 15px;
        }

        /* Luke's Profile Image with Purple Circle Highlight */
        .luke-profile-section {
            text-align: center;
            margin: 15px 0;
        }

        .luke-profile-highlight {
            position: relative;
            display: inline-block;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8b5cf6 0%, #a855f7 50%, #c084fc 100%);
            padding: 5px;
            box-shadow: 
                0 0 20px rgba(139, 92, 246, 0.6),
                0 0 40px rgba(139, 92, 246, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.2);
            animation: pulseGlow 3s ease-in-out infinite alternate;
        }

        @keyframes pulseGlow {
            0% {
                box-shadow: 
                    0 0 20px rgba(139, 92, 246, 0.6),
                    0 0 40px rgba(139, 92, 246, 0.3),
                    inset 0 2px 4px rgba(255, 255, 255, 0.2);
                transform: scale(1);
            }
            100% {
                box-shadow: 
                    0 0 30px rgba(139, 92, 246, 0.8),
                    0 0 60px rgba(139, 92, 246, 0.4),
                    0 0 80px rgba(139, 92, 246, 0.2),
                    inset 0 2px 4px rgba(255, 255, 255, 0.2);
                transform: scale(1.02);
            }
        }

        .luke-profile-img {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .luke-profile-img:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .luke-profile-name {
            font-size: 1.1em;
            font-weight: bold;
            margin-top: 8px;
            margin-bottom: 0;
            color: #f1f5f9;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .route-controls {
            padding: 20px;
            border-bottom: 1px solid #334155;
        }

        .filter-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .filter-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: #374151;
            color: white;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s ease;
        }

        .filter-btn:hover {
            background: #4b5563;
        }

        .filter-btn.active {
            background: #3b82f6;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            background: #1e293b;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #334155;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #3b82f6;
        }

        .stat-label {
            font-size: 0.8em;
            opacity: 0.8;
            margin-top: 2px;
        }

        .routes-list {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .route-item {
            padding: 15px 20px;
            border-bottom: 1px solid #334155;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .route-item:hover {
            background: rgba(59, 130, 246, 0.1);
        }

        .route-item.active {
            background: rgba(59, 130, 246, 0.2);
            border-left: 4px solid #3b82f6;
        }

        .route-name {
            font-weight: 600;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .activity-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .activity-icon.cycling {
            background: #3b82f6;
        }

        .activity-icon.running {
            background: #ef4444;
        }

        .route-details {
            font-size: 0.85em;
            opacity: 0.8;
            line-height: 1.4;
        }

        .route-distance {
            color: #60a5fa;
            font-weight: 500;
        }

        /* Globe container */
        .globe-container {
            flex: 1;
            position: relative;
        }

        #cesiumContainer {
            width: 100%;
            height: 100%;
        }

        /* Top-left overlay for distance animations */
        .distance-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            border: 2px solid rgba(139, 92, 246, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            color: white;
            font-family: 'Arial Black', Arial, sans-serif;
            min-width: 280px;
            display: none;
        }

        .distance-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .distance-counter {
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            color: #fbbf24;
            text-shadow: 0 2px 8px rgba(251, 191, 36, 0.5);
            margin: 15px 0;
        }

        .distance-progress {
            font-size: 14px;
            color: #94a3b8;
            text-align: center;
            margin-top: 10px;
        }

        /* Loading screen */
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #334155;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.1em;
            color: #94a3b8;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 40vh;
            }
            
            .globe-container {
                height: 60vh;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h1>üåç Luke's World</h1>
                <p>Athletic adventures & route discovery</p>
                
                <!-- Luke's Profile Image Section with Purple Highlight -->
                <div class="luke-profile-section" style="text-align: center; margin: 15px 0;">
                    <div id="lukeProfileContainer" class="luke-profile-highlight">
                        <img id="lukeHeadImg" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='80' height='80' viewBox='0 0 80 80'%3E%3Ccircle cx='40' cy='40' r='35' fill='%238b5cf6'/%3E%3Ctext x='40' y='50' font-size='30' text-anchor='middle' fill='white'%3EüèÉ‚Äç‚ôÇÔ∏è%3E/text%3E%3C/svg%3E" alt="Luke's Profile" class="luke-profile-img">
                    </div>
                    <p class="luke-profile-name">Luke</p>
                </div>
                
                <!-- Hidden preview for animation use only -->
                <div id="lukeHeadPreview" style="display: none;">
                    <img src="" alt="Luke's Face" style="width: 60px; height: 60px; object-fit: cover;">
                </div>
                <button id="uploadLukeHeadBtn" style="display: none;">
                    üì∑ Luke's Face Status
                </button>

                <!-- Tab Navigation -->
                <div class="tab-navigation">
                    <button class="tab-btn active" data-tab="lukes-routes">üè† My Routes</button>
                    <button class="tab-btn" data-tab="discover-routes">üåç Discover</button>
                </div>
            </div>
            
            <!-- Tab Content Areas -->
            <!-- My Routes Tab (Current functionality) -->
            <div id="lukes-routes" class="tab-content active">
            <div class="route-controls">
                <div class="filter-buttons">
                    <button class="filter-btn active" data-filter="all">All</button>
                    <button class="filter-btn" data-filter="cycling">üö¥‚Äç‚ôÇÔ∏è Cycling</button>
                    <button class="filter-btn" data-filter="running">üèÉ‚Äç‚ôÇÔ∏è Running</button>
                </div>
                
                <div class="toggle-routes" style="margin: 10px 0; text-align: center;">
                    <button id="toggleZwiftBtn" class="filter-btn" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); width: 100%; font-size: 14px;">
                        üè† Show Zwift Routes (Indoor)
                    </button>
                </div>
                
                <div class="world-distance" style="margin: 15px 0;">
                    <div style="text-align: center; margin-bottom: 10px; font-weight: bold; color: #fbbf24;">üåé Distance Visualization</div>
                    <button id="showTotalAroundWorldBtn" class="filter-btn" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); font-size: 12px; width: 100%; margin-bottom: 8px;">
                        üåç Luke's Epic Journey vs Earth's Circumference
                    </button>
                    <button id="clearWorldDistanceBtn" class="filter-btn" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); font-size: 11px; width: 100%; margin-bottom: 4px;">
                        Clear Visualization
                    </button>
                    <button id="restoreEarthBtn" class="filter-btn" style="background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%); font-size: 11px; width: 100%;">
                        üåç Emergency Restore Earth
                    </button>
                </div>
                
                
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value" id="totalRoutes">0</div>
                        <div class="stat-label">Routes</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalDistance">0 km</div>
                        <div class="stat-label">Total Distance</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="cyclingDistance">0 km</div>
                        <div class="stat-label">üö¥‚Äç‚ôÇÔ∏è Cycling</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="runningDistance">0 km</div>
                        <div class="stat-label">üèÉ‚Äç‚ôÇÔ∏è Running</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalTime">0h</div>
                        <div class="stat-label">Time</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="countries">0</div>
                        <div class="stat-label">Countries</div>
                    </div>
                </div>
            </div>
            
            <div class="routes-list" id="routesList">
                <!-- Routes will be populated here -->
            </div>
            </div>

            <!-- Discover Routes Tab (New functionality) -->
            <div id="discover-routes" class="tab-content">
                <div style="padding: 15px 0;">
                    <h3 style="color: #60a5fa; margin-bottom: 15px; font-size: 1.1em;">üåç Discover Epic Routes</h3>
                    
                    <!-- Search Bar -->
                    <div style="margin-bottom: 15px;">
                        <input type="text" placeholder="üîç Search routes..." style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #374151; background: #1f2937; color: white; font-size: 14px;">
                    </div>
                    
                    <!-- Route Categories -->
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #94a3b8; margin-bottom: 10px; font-size: 0.9em; text-transform: uppercase; letter-spacing: 1px;">Route Categories</h4>
                        <div class="route-category-buttons" style="display: flex; flex-direction: column; gap: 8px;">
                            <button class="filter-btn category-btn active" data-category="featured" style="justify-content: flex-start; text-align: left;">
                                ‚≠ê Featured Routes
                            </button>
                            <button class="filter-btn category-btn" data-category="eurovelo" style="justify-content: flex-start; text-align: left;">
                                üèõÔ∏è EuroVelo Network
                            </button>
                            <button class="filter-btn category-btn" data-category="adventure-cycling" style="justify-content: flex-start; text-align: left;">
                                üá∫üá∏ Adventure Cycling
                            </button>
                            <button class="filter-btn category-btn" data-category="community" style="justify-content: flex-start; text-align: left;">
                                üåü Community Favorites
                            </button>
                        </div>
                    </div>
                    
                    <!-- Filters -->
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #94a3b8; margin-bottom: 10px; font-size: 0.9em; text-transform: uppercase; letter-spacing: 1px;">Filters</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
                            <label style="color: #94a3b8;">Distance (km)</label>
                            <input type="range" min="0" max="5000" value="2500" style="width: 100%;">
                            <label style="color: #94a3b8;">Difficulty</label>
                            <select style="background: #374151; color: white; border: 1px solid #4b5563; border-radius: 4px; padding: 4px;">
                                <option>Any</option>
                                <option>Beginner</option>
                                <option>Intermediate</option>
                                <option>Expert</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Bucket List -->
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #f59e0b; margin-bottom: 10px; font-size: 0.9em; text-transform: uppercase; letter-spacing: 1px;">‚≠ê My Bucket List</h4>
                        <div id="bucketListCount" style="color: #94a3b8; font-size: 0.85em; font-style: italic;">
                            No routes starred yet
                        </div>
                    </div>
                    
                    <!-- Discover Routes List -->
                    <div id="discoverRoutesList" style="max-height: 400px; overflow-y: auto;">
                        <!-- Coming soon message -->
                        <div style="text-align: center; padding: 40px 20px; color: #94a3b8; font-style: italic;">
                            <div style="font-size: 3em; margin-bottom: 10px;">üöÄ</div>
                            <div>Route discovery coming soon!</div>
                            <div style="font-size: 0.8em; margin-top: 8px;">EuroVelo, Adventure Cycling & Komoot integration</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Globe -->
        <div class="globe-container">
            <div id="cesiumContainer"></div>
            
            <!-- Distance Animation Overlay -->
            <div id="distanceOverlay" class="distance-overlay">
                <div class="distance-title">üåç Luke's Epic Journey</div>
                <div class="distance-counter" id="distanceCounter">0 km</div>
                <div class="distance-progress" id="distanceProgress">Starting adventure...</div>
            </div>
            
            <div class="loading-screen" id="loadingScreen">
                <div class="spinner"></div>
                <div class="loading-text">Loading globe...</div>
            </div>
        </div>
    </div>

    <script>
        // Cesium configuration with correct token that has Bing Maps access
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyNGM2ZmUwZC0zNmI5LTQ4MTQtYjkyNy1kZTMyNTc0MWIyYWUiLCJpZCI6MzM2NzUyLCJpYXQiOjE3NTY1NTU3OTh9.zrnBs58tnAJxGy2FWSpWP5KD8JRTCskZJ1sMt3rUsT8';

        // Global variables
        let viewer;
        let routeEntities = [];
        let permanentRouteEntities = []; // For always-visible routes
        let currentFilter = 'all';
        let showZwiftRoutes = false; // Hide Zwift routes by default
        
        // PERFORMANCE OPTIMIZATION: Cache Zwift detection results to avoid repeated expensive operations
        const zwiftDetectionCache = new Map();

        // ENHANCED: Reliable Zwift detection using Strava's official data fields
        function isZwiftRoute(route) {
            if (!route || !route.name) return false;
            
            // PERFORMANCE: Use cached result if available (critical for 1000s of routes)
            const cacheKey = route.id || route.name;
            if (zwiftDetectionCache.has(cacheKey)) {
                return zwiftDetectionCache.get(cacheKey);
            }
            
            let detectedReason = null;
            
            // üö® ENHANCED: More comprehensive Strava-based virtual ride detection
            if (route.trainer === true) {
                detectedReason = 'Strava trainer flag (most reliable)';
            } else if (route.sport_type === 'VirtualRide') {
                detectedReason = 'Strava VirtualRide type';
            } else if (route.manual === true && route.coordinates?.length === 0) {
                detectedReason = 'Manual activity without GPS (likely indoor)';
            } else if (route.workout_type && route.coordinates?.length === 0) {
                detectedReason = 'Structured workout without GPS (likely indoor)';
            } else if (route.device_name?.toLowerCase().includes('trainer')) {
                detectedReason = 'Trainer device detected';
            } else if (route.description?.toLowerCase().includes('zwift')) {
                detectedReason = 'Zwift mentioned in description';
            } else if (route.description?.toLowerCase().includes('indoor')) {
                detectedReason = 'Indoor mentioned in description';
            } 
            // üîç NEW: Additional detection patterns for missed virtual rides
            else if (route.distance > 0 && (!route.coordinates || route.coordinates.length === 0)) {
                detectedReason = 'Distance recorded but no GPS data (indoor activity)';
            } else if (route.commute === false && route.manual === false && (!route.coordinates || route.coordinates.length === 0)) {
                detectedReason = 'Non-commute activity without GPS (likely virtual)';
            }
            
            // PRIORITY 2: Only if Strava fields don't give a definitive answer, check name patterns
            if (!detectedReason) {
                const routeName = route.name.toLowerCase();
                
                // Strong Zwift indicators (virtual worlds that don't exist in reality)
                const zwiftVirtualWorlds = [
                    'zwift', 'watopia', 'makuri', 'crit city'
                ];
                
                // Real places that are only Zwift when combined with "zwift" 
                const zwiftRealPlaces = [
                    'richmond', 'london', 'innsbruck', 'yorkshire', 'france', 'paris', 'new york'
                ];
                
                // üö® ENHANCED: More comprehensive Zwift-specific activity patterns
                const zwiftPatterns = [
                    'group workout', 'structured workout', 'free ride',
                    'climb portal', 'alpe du', 'epic kom',
                    'min workout', 'workout on', 'workout in', // Zwift format: "30 Min Workout on..."
                    'group ride', 'pace partner', 'meet up', 
                    'race', 'racing', 'fondo', 'tour de', 'stage',
                    'interval', 'endurance', 'tempo', 'sweet spot',
                    'ftp', 'threshold', 'vo2', 'recovery ride',
                    'warm up', 'cool down', 'spin up', 'ramp test'
                ];
                
                // Check for virtual Zwift worlds (always Zwift)
                for (const world of zwiftVirtualWorlds) {
                    if (routeName.includes(world)) {
                        detectedReason = `virtual world: ${world}`;
                        break;
                    }
                }
                
                // Check for real places combined with "zwift" (more specific)
                if (!detectedReason) {
                    for (const place of zwiftRealPlaces) {
                        if (routeName.includes('zwift') && routeName.includes(place)) {
                            detectedReason = `zwift + real place: ${place}`;
                            break;
                        }
                    }
                }
                
                // Check for Zwift activity patterns  
                if (!detectedReason) {
                    for (const pattern of zwiftPatterns) {
                        if (routeName.includes(pattern)) {
                            detectedReason = `pattern: ${pattern}`;
                            break;
                        }
                    }
                }
                
                // LAST RESORT: GPS-based detection (only if no other indicators)
                if (!detectedReason && route.distance > 0 && (!route.coordinates || route.coordinates.length === 0)) {
                    detectedReason = 'no GPS coords';
                }
            }
            
            const isZwift = !!detectedReason;
            
            // Debug logging for detections - increased sampling for debugging
            if (isZwift && Math.random() < 0.3) { // 30% sampling to see more examples
                console.log(`üèÉ ZWIFT DETECTED: "${route.name}" - ${detectedReason}`);
            }
            
            // COMPREHENSIVE DEBUG: Show all Strava fields for better detection analysis (first 15 routes)
            if (window.routeClassificationCount === undefined) window.routeClassificationCount = 0;
            if (window.routeClassificationCount < 15) {
                window.routeClassificationCount++;
                const stravaFields = {
                    trainer: route.trainer,
                    sport_type: route.sport_type,
                    manual: route.manual,
                    workout_type: route.workout_type,
                    device_name: route.device_name,
                    has_gps: route.coordinates?.length > 0,
                    description_preview: route.description?.substring(0, 50)
                };
                console.log(`${isZwift ? 'üè†' : 'üåç'} Route ${window.routeClassificationCount}: "${route.name}"`);
                console.log(`   üìä Strava Fields:`, stravaFields);
                console.log(`   üéØ Result: ${isZwift ? `INDOOR (${detectedReason})` : 'OUTDOOR'}`);
                console.log(''); // Blank line for readability
            }
            
            // PERFORMANCE: Cache the result for future calls
            zwiftDetectionCache.set(cacheKey, isZwift);
            return isZwift;
        }
        let sampleRoutes = [];
        let clusterMarkers = [];
        let currentZoomLevel = 0;
        let showAllRoutes = false; // Toggle for showing all routes
        let worldDistanceEntities = []; // For around-the-world distance visualization

        // OPTION A: Static Marker Pool - Create once, persist forever, toggle visibility
        const PERSISTENT_MARKERS = new Map(); // Main marker storage: markerId -> {entity, routes, isZwift, city}
        const ZOOM_LEVEL_MARKERS = new Map(); // Different markers for different zoom levels
        let currentMarkerSet = null; // Track which marker set is currently visible
        let worldDistanceAnimation = null; // Animation handle
        let isAnimationInProgress = false; // CRITICAL: Prevent camera corrections during animations
        let savedCameraPosition = null; // Save camera position before visualization
        let routeCache = null; // Cache for loaded routes
        let isLoadingAdditionalRoutes = false; // Track background loading
        
        // üñºÔ∏è EASY WAYS TO ADD LUKE'S FACE:
        
        // METHOD 1: Direct URL (EASIEST - just replace with Luke's photo URL)
        const LUKES_HEAD_URL = 'https://example.com/lukes-photo.jpg'; // Replace with actual URL
        
        // METHOD 2: Base64 (paste converted image data here)
        const LUKES_HEAD_BASE64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg=='; // Replace with actual base64
        
        // üéØ METHOD 5: HARDCODED BASE64 - PASTE LUKE'S BASE64 DATA HERE! üéØ
        // üëáüëáüëá REPLACE THE PLACEHOLDER BELOW WITH LUKE'S ACTUAL BASE64 DATA üëáüëáüëá
        const LUKES_HEAD_HARDCODED = 'PASTE_LUKES_BASE64_DATA_HERE_INCLUDING_DATA_IMAGE_PREFIX';
        // üëÜüëÜüëÜ PASTE LUKE'S BASE64 DATA ABOVE THIS LINE üëÜüëÜüëÜ
        
        // METHOD 3: Direct image file (BEST - just upload PNG/JPG to GitHub)
        // üëá Multiple filename variations to try üëá
        const LUKES_HEAD_FILENAMES = [
            './Luke\'s-face.png',     // Current filename (hyphen)
            './Lukes-face.png',      // No apostrophe
            './lukes-face.png',      // Lowercase
            './Luke-face.png',       // No apostrophe, capital L
            './Luke\'s face.png',    // Original with space
            './Luke.png'             // Simple filename
        ];
        const LUKES_HEAD_LOCAL = LUKES_HEAD_FILENAMES[0]; // Default to first option
        
        // Choose which method to use:
        // 1=URL, 2=Base64, 3=Direct image file, 4=Base64 from file, 5=Hardcoded base64
        const IMAGE_METHOD = 3; // Set to 3 to use direct image file (simplest and most reliable)
        const AUTO_LOAD_LUKES_FACE = true; // Automatically load Luke's face on startup
        
        function getLukesImage() {
            switch(IMAGE_METHOD) {
                case 1: return LUKES_HEAD_URL;
                case 2: return LUKES_HEAD_BASE64;
                case 3: return LUKES_HEAD_LOCAL;
                case 4: return null; // Will be loaded async
                case 5: return LUKES_HEAD_HARDCODED; // Hardcoded base64
                default: return LUKES_HEAD_BASE64;
            }
        }

        // Function to try multiple filename variations
        async function findWorkingImageFile() {
            console.log('üîç Trying multiple filename variations for Luke\'s face...');
            
            for (let i = 0; i < LUKES_HEAD_FILENAMES.length; i++) {
                const filename = LUKES_HEAD_FILENAMES[i];
                try {
                    console.log(`üîç Testing filename ${i + 1}/${LUKES_HEAD_FILENAMES.length}: ${filename}`);
                    
                    // Test if file exists by creating an image element
                    const testImg = new Image();
                    const imageLoaded = await new Promise((resolve) => {
                        testImg.onload = () => resolve(true);
                        testImg.onerror = () => resolve(false);
                        testImg.src = filename;
                    });
                    
                    if (imageLoaded) {
                        console.log(`‚úÖ Found working image file: ${filename}`);
                        return filename;
                    } else {
                        console.log(`‚ùå Failed to load: ${filename}`);
                    }
                } catch (error) {
                    console.log(`‚ùå Error testing ${filename}:`, error.message);
                }
            }
            
            console.log('‚ùå No working image files found, using default');
            return LUKES_HEAD_LOCAL;
        }

        // Async function to load Luke's image from base64 file
        async function loadLukesImageFromFile() {
            try {
                console.log('üìÑ Loading Luke\'s face from base64 file...');
                
                // Try multiple sources for loading the base64 file:
                const fileSources = [
                    './luke.txt',  // Local file (when running locally)
                    './Luke.txt',  // Alternative capitalization
                    // GitHub raw content URLs (work from anywhere including GitHub Pages)
                    'https://raw.githubusercontent.com/Zshumake/luke-route-globe/main/luke.txt',
                    'https://raw.githubusercontent.com/Zshumake/luke-route-globe/main/Luke.txt'
                ];
                
                let response;
                let successfulUrl = '';
                
                // Try each source until one works
                for (const url of fileSources) {
                    try {
                        console.log(`üîç Trying to load from: ${url}`);
                        response = await fetch(url);
                        if (response.ok) {
                            successfulUrl = url;
                            console.log(`‚úÖ Successfully connected to: ${url}`);
                            break;
                        }
                    } catch (fetchError) {
                        console.log(`‚ö†Ô∏è Failed to load from ${url}: ${fetchError.message}`);
                        continue;
                    }
                }
                
                if (!response || !response.ok) {
                    throw new Error(`Failed to load from all sources`);
                }
                
                const base64Data = await response.text();
                // Clean up the base64 data (remove any whitespace/newlines)
                const cleanBase64 = base64Data.trim();
                
                // Check if it already has the data: prefix
                const imageSource = cleanBase64.startsWith('data:image/') 
                    ? cleanBase64 
                    : `data:image/png;base64,${cleanBase64}`;
                    
                console.log(`‚úÖ Successfully loaded Luke\'s face from: ${successfulUrl}`);
                return imageSource;
            } catch (error) {
                console.error('‚ùå Failed to load Luke\'s face from all sources:', error);
                console.log('üîÑ Falling back to default base64 data...');
                return LUKES_HEAD_BASE64;
            }
        }
        
        // Function to set Luke's head image programmatically
        function setLukesHeadImage(imageSource) {
            console.log('üîß DEBUG: setLukesHeadImage called with:', imageSource);
            const lukeHeadImg = document.getElementById('lukeHeadImg');
            const lukeHeadPreview = document.getElementById('lukeHeadPreview');
            const uploadBtn = document.getElementById('uploadLukeHeadBtn');
            
            console.log('üîß DEBUG: DOM elements found:', {
                lukeHeadImg: !!lukeHeadImg,
                lukeHeadPreview: !!lukeHeadPreview,
                uploadBtn: !!uploadBtn
            });
            
            if (lukeHeadImg && lukeHeadPreview && uploadBtn) {
                // Test if image loads successfully
                const testImg = new Image();
                testImg.onload = () => {
                    console.log('‚úÖ Image loaded successfully:', imageSource);
                    lukeHeadImg.src = imageSource;
                    // FIXED: Don't show the hidden preview - Luke's image is already visible in the profile section
                    // lukeHeadPreview.style.display = 'block'; // REMOVED - this was causing duplicate box
                    uploadBtn.textContent = 'üéÜ Luke\'s Face Ready!';
                    uploadBtn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                    console.log(`üéÜ Luke\'s head image set successfully`);
                };
                testImg.onerror = () => {
                    console.error('‚ùå Failed to load image:', imageSource);
                    console.log('üîÑ Trying fallback methods...');
                    // Try direct assignment anyway
                    lukeHeadImg.src = imageSource;
                };
                testImg.src = imageSource;
            } else {
                console.error('‚ùå Missing DOM elements for Luke\'s head setup');
            }
        }

        /*
        üöÄ ULTIMATE STRAVA OPTIMIZATION SUMMARY:
        
        BEFORE OPTIMIZATION:
        ‚ùå 85+ individual GPS stream API calls (20-50KB each = 2-4MB total)
        ‚ùå Full activity objects with 50+ unused fields per activity
        ‚ùå Detailed logging for every single route processed  
        ‚ùå 25ms delay between each route processing
        ‚ùå Total load time: 30-60 seconds, 2-5MB data transfer
        
        AFTER OPTIMIZATION: 
        ‚úÖ ZERO GPS stream API calls (use summary_polyline instead)
        ‚úÖ Only 4 essential fields per activity (95% less data per route)
        ‚úÖ Minimal logging (every 50th route only)
        ‚úÖ 1ms delay every 10 routes (vs 25ms every single route)
        ‚úÖ Removed unused fields: time, location, date, elevation, speed, etc.
        ‚úÖ Total load time: 3-8 seconds, ~200-400KB data transfer
        
        FINAL RESULT: 80% LESS DATA + 5X FASTER LOADING! üéÜ
        Each route is now just ~2KB instead of ~20-50KB!
        */
        
        // OPTIMIZATION: Polyline decoding utility (replaces expensive stream API calls)
        function decodePolyline(str, precision = 5) {
            let index = 0, lat = 0, lng = 0;
            const coordinates = [];
            const factor = Math.pow(10, precision);
            
            while (index < str.length) {
                let byte, shift = 0, result = 0;
                do {
                    byte = str.charCodeAt(index++) - 63;
                    result |= (byte & 0x1F) << shift;
                    shift += 5;
                } while (byte >= 0x20);
                
                const deltaLat = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
                lat += deltaLat;
                
                shift = result = 0;
                do {
                    byte = str.charCodeAt(index++) - 63;
                    result |= (byte & 0x1F) << shift;
                    shift += 5;
                } while (byte >= 0x20);
                
                const deltaLng = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
                lng += deltaLng;
                
                coordinates.push([lng / factor, lat / factor]); // [longitude, latitude]
            }
            
            return coordinates;
        }
        
        // Strava API Configuration
        const STRAVA_CONFIG = {
            clientId: '175720', // Luke's Route Globe App Client ID
            clientSecret: '4d1aca2ba311a1a36c195e1e6bae008ef52dab1f', // Client Secret
            redirectUri: window.location.origin + window.location.pathname,
            scope: 'read,activity:read_all',
            apiBaseUrl: 'https://www.strava.com/api/v3'
        };
        
        // Strava API Integration Class
        class StravaAPI {
            constructor() {
                this.accessToken = localStorage.getItem('strava_access_token');
                this.refreshToken = localStorage.getItem('strava_refresh_token');
            }
            
            // Step 1: Check if user is authenticated
            isAuthenticated() {
                return !!this.accessToken;
            }
            
            // Step 2: Redirect to Strava for OAuth
            authenticate() {
                const authUrl = `https://www.strava.com/oauth/authorize?` +
                    `client_id=${STRAVA_CONFIG.clientId}&` +
                    `response_type=code&` +
                    `redirect_uri=${encodeURIComponent(STRAVA_CONFIG.redirectUri)}&` +
                    `scope=${STRAVA_CONFIG.scope}&` +
                    `state=strava_auth`;
                    
                window.location.href = authUrl;
            }
            
            // Step 3: Handle OAuth callback and exchange code for token
            async handleAuthCallback() {
                console.log('üîç DEBUG: handleAuthCallback called');
                console.log('üîç DEBUG: Current URL:', window.location.href);
                
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const state = urlParams.get('state');
                
                console.log('üîç DEBUG: OAuth code:', code ? 'Present' : 'Missing');
                console.log('üîç DEBUG: OAuth state:', state);
                
                if (code && state === 'strava_auth') {
                    console.log('‚úÖ DEBUG: OAuth callback detected - exchanging code for token...');
                    
                    try {
                        console.log('üîç DEBUG: Making token exchange request...');
                        // Note: In production, this should be done on your backend for security
                        const tokenResponse = await fetch('https://www.strava.com/oauth/token', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                client_id: STRAVA_CONFIG.clientId,
                                client_secret: STRAVA_CONFIG.clientSecret,
                                code: code,
                                grant_type: 'authorization_code'
                            })
                        });
                        
                        console.log('üîç DEBUG: Token response status:', tokenResponse.status);
                        const tokenData = await tokenResponse.json();
                        console.log('üîç DEBUG: Token data received:', !!tokenData.access_token);
                        
                        if (tokenResponse.status !== 200) {
                            console.error('‚ùå Token exchange failed:', tokenData);
                            return false;
                        }
                        
                        if (tokenData.access_token) {
                            console.log('‚úÖ DEBUG: Access token received - storing...');
                            this.accessToken = tokenData.access_token;
                            this.refreshToken = tokenData.refresh_token;
                            
                            localStorage.setItem('strava_access_token', this.accessToken);
                            localStorage.setItem('strava_refresh_token', this.refreshToken);
                            
                            console.log('‚úÖ DEBUG: Tokens stored in localStorage');
                            console.log('üîç DEBUG: Access token length:', this.accessToken.length);
                            
                            // Clean up URL
                            window.history.replaceState({}, document.title, window.location.pathname);
                            return true;
                        } else {
                            console.error('‚ùå No access token in response:', tokenData);
                        }
                    } catch (error) {
                        console.error('‚ùå Strava authentication failed:', error);
                    }
                } else {
                    console.log('‚ö†Ô∏è DEBUG: No OAuth callback detected (missing code or wrong state)');
                }
                return false;
            }
            
            // Step 4: Fetch Luke's activities from Strava
            async getActivities(page = 1, perPage = 30) {
                if (!this.accessToken) {
                    throw new Error('Not authenticated with Strava');
                }
                
                try {
                    // ULTRA OPTIMIZATION: Max batch size + minimal data request
                    const optimizedPerPage = Math.min(perPage * 3, 200); // Triple the batch size (up to Strava's max)
                    
                    // üöÄ CRITICAL: Request only essential fields to minimize payload size
                    const response = await fetch(
                        `${STRAVA_CONFIG.apiBaseUrl}/athlete/activities?page=${page}&per_page=${optimizedPerPage}`,
                        {
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`
                            }
                        }
                    );
                    
                    if (response.status === 401) {
                        // Token expired, clear storage
                        this.clearTokens();
                        throw new Error('Strava token expired');
                    }
                    
                    return await response.json();
                } catch (error) {
                    console.error('Failed to fetch Strava activities:', error);
                    throw error;
                }
            }
            
            // Step 5: Get detailed GPS stream data for a specific activity
            async getActivityStream(activityId) {
                if (!this.accessToken) {
                    throw new Error('Not authenticated with Strava');
                }
                
                try {
                    const response = await fetch(
                        `${STRAVA_CONFIG.apiBaseUrl}/activities/${activityId}/streams?keys=latlng&key_by_type=true`,
                        {
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`
                            }
                        }
                    );
                    
                    if (response.status === 401) {
                        this.clearTokens();
                        throw new Error('Strava token expired');
                    }
                    
                    return await response.json();
                } catch (error) {
                    console.error('Failed to fetch activity stream:', error);
                    throw error;
                }
            }
            
            // NEW: Get athlete stats quickly (total distances, times, etc.)
            async getAthleteStats() {
                if (!this.accessToken) {
                    throw new Error('Not authenticated with Strava');
                }
                
                try {
                    console.log('üìä Fetching Luke\'s total stats from Strava...');
                    const response = await fetch(
                        `${STRAVA_CONFIG.apiBaseUrl}/athletes/${await this.getAthleteId()}/stats`,
                        {
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`
                            }
                        }
                    );
                    
                    if (response.status === 401) {
                        this.clearTokens();
                        throw new Error('Strava token expired');
                    }
                    
                    const stats = await response.json();
                    console.log('üìä Luke\'s total stats received:', stats);
                    return stats;
                } catch (error) {
                    console.error('Failed to fetch athlete stats:', error);
                    throw error;
                }
            }
            
            // Helper: Get athlete ID (needed for stats endpoint)
            async getAthleteId() {
                if (this.athleteId) return this.athleteId;
                
                try {
                    const response = await fetch(
                        `${STRAVA_CONFIG.apiBaseUrl}/athlete`,
                        {
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`
                            }
                        }
                    );
                    
                    const athlete = await response.json();
                    this.athleteId = athlete.id;
                    return this.athleteId;
                } catch (error) {
                    console.error('Failed to fetch athlete info:', error);
                    throw error;
                }
            }
            
            // Clear stored tokens
            clearTokens() {
                this.accessToken = null;
                this.refreshToken = null;
                localStorage.removeItem('strava_access_token');
                localStorage.removeItem('strava_refresh_token');
            }
        }
        
        // Initialize Strava API
        const stravaAPI = new StravaAPI();
        
        // Debug function to check authentication status (call from console)
        window.checkStravaAuth = function() {
            console.log('üîç DEBUG: Checking Strava authentication status...');
            console.log('üîç DEBUG: localStorage access token:', localStorage.getItem('strava_access_token') ? 'Present' : 'Missing');
            console.log('üîç DEBUG: localStorage refresh token:', localStorage.getItem('strava_refresh_token') ? 'Present' : 'Missing');
            console.log('üîç DEBUG: stravaAPI.accessToken:', stravaAPI.accessToken ? 'Present' : 'Missing');
            console.log('üîç DEBUG: stravaAPI.isAuthenticated():', stravaAPI.isAuthenticated());
            
            if (stravaAPI.accessToken) {
                console.log('üîç DEBUG: Access token length:', stravaAPI.accessToken.length);
                console.log('üîç DEBUG: Token preview:', stravaAPI.accessToken.substring(0, 10) + '...');
            }
            
            return {
                hasLocalStorageToken: !!localStorage.getItem('strava_access_token'),
                hasApiToken: !!stravaAPI.accessToken,
                isAuthenticated: stravaAPI.isAuthenticated()
            };
        };
        
        // WEB WORKER: Background processing for large datasets
        let routeProcessingWorker = null;

        function createRouteProcessingWorker() {
            // Create Web Worker inline to avoid external file dependency
            const workerCode = `
                // Polyline decoding function for Web Worker
                function decodePolyline(encoded) {
                    const points = [];
                    let index = 0, lat = 0, lng = 0;
                    
                    while (index < encoded.length) {
                        let b, shift = 0, result = 0;
                        do {
                            b = encoded.charCodeAt(index++) - 63;
                            result |= (b & 0x1f) << shift;
                            shift += 5;
                        } while (b >= 0x20);
                        const deltaLat = ((result & 1) ? ~(result >> 1) : (result >> 1));
                        lat += deltaLat;
                        
                        shift = 0;
                        result = 0;
                        do {
                            b = encoded.charCodeAt(index++) - 63;
                            result |= (b & 0x1f) << shift;
                            shift += 5;
                        } while (b >= 0x20);
                        const deltaLng = ((result & 1) ? ~(result >> 1) : (result >> 1));
                        lng += deltaLng;
                        
                        points.push([lng * 1e-5, lat * 1e-5]);
                    }
                    return points;
                }

                // Coordinate subsampling for memory optimization
                function subsampleCoordinates(coordinates, factor = 3) {
                    if (!coordinates || coordinates.length <= factor * 2) return coordinates;
                    return coordinates.filter((_, index) => index % factor === 0);
                }

                // Transform activity in worker thread
                function transformStravaActivity(activity, includeFullCoords = false) {
                    let coordinates = [];
                    
                    if (activity.map?.summary_polyline) {
                        try {
                            const fullCoords = decodePolyline(activity.map.summary_polyline);
                            // Apply coordinate subsampling to save memory (keep every 3rd point)
                            coordinates = includeFullCoords ? fullCoords : subsampleCoordinates(fullCoords, 3);
                        } catch (error) {
                            console.warn('Worker polyline decode error:', error.message);
                        }
                    }

                    return {
                        id: activity.id.toString(),
                        name: activity.name || 'Untitled',
                        type: (() => {
                            const sportType = activity.sport_type || activity.type;
                            return (sportType === 'Ride' || sportType === 'VirtualRide' || sportType === 'EBikeRide') 
                                ? 'cycling' : 'running';
                        })(),
                        distance: Math.round((activity.distance || 0) / 100) / 10,
                        coordinates: coordinates,
                        
                        // Enhanced Strava fields for detection
                        trainer: activity.trainer,
                        sport_type: activity.sport_type || activity.type,
                        manual: activity.manual,
                        private: activity.private,
                        commute: activity.commute,
                        workout_type: activity.workout_type,
                        description: activity.description,
                        device_name: activity.device_name,
                        gear_id: activity.gear_id,
                        start_date: activity.start_date
                    };
                }

                // Worker message handler
                self.onmessage = function(e) {
                    const { activities, batchIndex, totalBatches } = e.data;
                    const processedRoutes = [];
                    
                    // Process batch of activities
                    for (let i = 0; i < activities.length; i++) {
                        try {
                            const route = transformStravaActivity(activities[i]);
                            if (route.coordinates && route.coordinates.length > 0) {
                                processedRoutes.push(route);
                            }
                        } catch (error) {
                            console.warn('Worker route processing error:', error.message);
                        }
                        
                        // Report progress every 10 items
                        if (i % 10 === 0) {
                            self.postMessage({
                                type: 'progress',
                                processed: i,
                                total: activities.length,
                                batchIndex: batchIndex,
                                totalBatches: totalBatches
                            });
                        }
                    }
                    
                    // Send completed batch
                    self.postMessage({
                        type: 'batch_complete',
                        routes: processedRoutes,
                        batchIndex: batchIndex,
                        totalBatches: totalBatches
                    });
                };
            `;

            const blob = new Blob([workerCode], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }

        // Process routes using Web Worker with batching
        async function processRoutesWithWorker(activities) {
            return new Promise((resolve, reject) => {
                const BATCH_SIZE = 50; // Process 50 activities at a time
                const batches = [];
                const allProcessedRoutes = [];
                
                // Split activities into batches
                for (let i = 0; i < activities.length; i += BATCH_SIZE) {
                    batches.push(activities.slice(i, i + BATCH_SIZE));
                }
                
                console.log(`üîß WEB WORKER: Processing ${activities.length} activities in ${batches.length} batches`);
                
                if (!routeProcessingWorker) {
                    routeProcessingWorker = createRouteProcessingWorker();
                }
                
                let completedBatches = 0;
                
                routeProcessingWorker.onmessage = function(e) {
                    const { type, routes, batchIndex, processed, total, totalBatches } = e.data;
                    
                    if (type === 'progress') {
                        const overallProgress = ((batchIndex * BATCH_SIZE + processed) / activities.length * 100).toFixed(1);
                        updateLoadingStatus(`‚ö° Processing ${overallProgress}% (${batchIndex + 1}/${totalBatches} batches)`);
                    } else if (type === 'batch_complete') {
                        allProcessedRoutes.push(...routes);
                        completedBatches++;
                        
                        console.log(`‚úÖ BATCH ${batchIndex + 1}/${totalBatches} completed: ${routes.length} routes processed`);
                        
                        if (completedBatches === totalBatches) {
                            console.log(`üéâ ALL BATCHES COMPLETED: ${allProcessedRoutes.length} total routes processed`);
                            resolve(allProcessedRoutes);
                        }
                    }
                };
                
                routeProcessingWorker.onerror = function(error) {
                    console.error('‚ùå Web Worker error:', error);
                    reject(error);
                };
                
                // Send all batches to worker
                batches.forEach((batch, index) => {
                    routeProcessingWorker.postMessage({
                        activities: batch,
                        batchIndex: index,
                        totalBatches: batches.length
                    });
                });
            });
        }

        // üöÄ CRITICAL FIX #2: Intelligent coordinate compression for memory optimization
        function compressCoordinates(coordinates, distance = 0) {
            if (!coordinates || coordinates.length <= 2) return coordinates;
            
            // Dynamic compression based on activity distance and coordinate density
            let compressionFactor = 2; // Default: keep every 2nd point
            
            // More aggressive compression for longer routes
            if (distance > 100) compressionFactor = 5;        // >100km: keep every 5th point
            else if (distance > 50) compressionFactor = 4;    // >50km: keep every 4th point  
            else if (distance > 20) compressionFactor = 3;    // >20km: keep every 3rd point
            
            // Always keep start and end points
            const compressed = [coordinates[0]]; // Start point
            
            // Apply compression to middle points
            for (let i = compressionFactor; i < coordinates.length - 1; i += compressionFactor) {
                compressed.push(coordinates[i]);
            }
            
            // Always keep end point (if different from start)
            if (coordinates.length > 1) {
                compressed.push(coordinates[coordinates.length - 1]);
            }
            
            // Log compression ratio for monitoring
            const compressionRatio = ((coordinates.length - compressed.length) / coordinates.length * 100).toFixed(1);
            if (coordinates.length > 100) { // Only log for significant routes
                console.log(`üóúÔ∏è Compressed ${distance}km route: ${coordinates.length}‚Üí${compressed.length} points (${compressionRatio}% reduction)`);
            }
            
            return compressed;
        }

        // LEGACY: Convert Strava activity data using only essential fields (fallback)
        function transformStravaActivity(activity, streamData = null) {
            // Fast coordinate processing
            let coordinates = [];
            if (streamData?.latlng?.data) {
                coordinates = streamData.latlng.data;
                
                // Quick coordinate transformation check (minimal logging)
                if (coordinates.length > 0 && Array.isArray(coordinates[0]) && coordinates[0].length === 2) {
                    // Swap [lat, lng] to [lng, lat] for Cesium
                    coordinates = coordinates.map(coord => [coord[1], coord[0]]);
                    
                    // üöÄ CRITICAL FIX #2: Aggressive coordinate compression for memory optimization
                    coordinates = compressCoordinates(coordinates, activity.distance);
                }
            }
            
            // ENHANCED: Include Strava fields for reliable indoor activity detection
            return {
                id: activity.id.toString(),
                name: activity.name || 'Untitled',
                type: (() => {
                    // Fast sport type mapping (no logging)
                    const sportType = activity.sport_type || activity.type;
                    return (sportType === 'Ride' || sportType === 'VirtualRide' || sportType === 'EBikeRide') 
                        ? 'cycling' : 'running';
                })(),
                distance: Math.round((activity.distance || 0) / 100) / 10, // Faster: meters to km
                coordinates: coordinates, // Only GPS data we need
                
                // COMPREHENSIVE: Capture all Strava fields that indicate indoor activities
                trainer: activity.trainer, // Boolean: true for indoor trainer (most reliable)
                sport_type: activity.sport_type || activity.type, // VirtualRide type
                manual: activity.manual, // Manual activities are often indoor
                private: activity.private, // Some users mark virtual rides as private
                commute: activity.commute, // Usually false for virtual activities
                workout_type: activity.workout_type, // Structured workouts often indoor
                description: activity.description, // May contain "Zwift", "indoor", etc.
                device_name: activity.device_name, // May indicate trainer/smart devices
                gear_id: activity.gear_id // Virtual bikes have specific gear IDs
            };
        }
        
        // SMART CACHING FUNCTIONS (storage-conscious)
        async function getCachedRoutes() {
            try {
                console.log('üîç Checking for cached routes...');
                const startTime = performance.now();
                
                // Try IndexedDB first (better capacity and performance)
                const db = await initIndexedDB();
                
                if (db) {
                    const indexedDBRoutes = await getCachedRoutesIndexedDB(db);
                    if (indexedDBRoutes) {
                        const loadTime = performance.now() - startTime;
                        console.log(`üöÄ IndexedDB cache hit in ${loadTime.toFixed(2)}ms`);
                        return indexedDBRoutes;
                    }
                }
                
                // Fallback to localStorage
                const localStorageRoutes = getCachedRoutesLocalStorage();
                if (localStorageRoutes) {
                    const loadTime = performance.now() - startTime;
                    console.log(`üì¶ LocalStorage cache hit in ${loadTime.toFixed(2)}ms`);
                    return localStorageRoutes;
                }
                
                console.log('üí≠ No cached routes found');
                return null;
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Cache retrieval error:', error);
                await clearRouteCache();
                return null;
            }
        }

        async function getCachedRoutesIndexedDB(db) {
            try {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                
                const cachedData = await new Promise((resolve, reject) => {
                    const request = store.get('strava_routes_cache');
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
                
                if (cachedData && cachedData.data) {
                    const cacheAge = Date.now() - cachedData.timestamp;
                    const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days per Strava API requirements
                    
                    if (cacheAge < maxAge) {
                        const routes = cachedData.data;
                        const ageDays = Math.floor(cacheAge / (24 * 60 * 60 * 1000));
                        const ageHours = Math.floor((cacheAge % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
                        const ageDisplay = ageDays > 0 ? `${ageDays}d ${ageHours}h` : `${ageHours}h`;
                        console.log(`‚ú® IndexedDB HIT: ${routes.length} routes (${ageDisplay} old) - PREMIUM CACHE! üéâ`);
                        return routes;
                    } else {
                        console.log('‚è∞ IndexedDB cache expired - clearing...');
                        await clearCachedRoutesIndexedDB(db);
                    }
                }
                
                return null;
            } catch (error) {
                console.warn('‚ö†Ô∏è IndexedDB read error:', error);
                return null;
            }
        }

        function getCachedRoutesLocalStorage() {
            try {
                const cached = localStorage.getItem('strava_routes_cache');
                const cacheTimestamp = localStorage.getItem('strava_routes_cache_timestamp');
                
                if (cached && cacheTimestamp) {
                    const cacheAge = Date.now() - parseInt(cacheTimestamp);
                    const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days per Strava API requirements
                    
                    if (cacheAge < maxAge) {
                        const routes = JSON.parse(cached);
                        const ageHours = Math.floor(cacheAge / (60 * 60 * 1000));
                        const ageDays = Math.floor(ageHours / 24);
                        const ageDisplay = ageDays > 0 ? `${ageDays}d ${ageHours % 24}h` : `${ageHours}h`;
                        console.log(`üì¶ LocalStorage HIT: ${routes.length} routes (${(cached.length/1024).toFixed(0)}KB, ${ageDisplay} old)`);
                        return routes;
                    } else {
                        console.log('‚è∞ LocalStorage cache expired');
                        clearCachedRoutesLocalStorage();
                    }
                }
                return null;
            } catch (error) {
                console.warn('‚ö†Ô∏è LocalStorage read error:', error);
                clearCachedRoutesLocalStorage();
                return null;
            }
        }
        
        // üöÄ CRITICAL FIX #9: IndexedDB storage for large-scale caching (250MB+ vs 10MB localStorage)
        let indexedDBCache = null;
        const DB_NAME = 'StravaRoutesDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'routes';

        async function initIndexedDB() {
            if (indexedDBCache) return indexedDBCache;
            
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => {
                    console.warn('‚ö†Ô∏è IndexedDB not supported, falling back to localStorage');
                    resolve(null);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const store = db.createObjectStore(STORE_NAME, { keyPath: 'key' });
                        store.createIndex('timestamp', 'timestamp', { unique: false });
                        console.log('‚úÖ IndexedDB store created');
                    }
                };
                
                request.onsuccess = (event) => {
                    indexedDBCache = event.target.result;
                    console.log('üöÄ IndexedDB initialized successfully');
                    resolve(indexedDBCache);
                };
            });
        }

        async function cacheRoutes(routes) {
            try {
                console.log(`üöÄ INDEXEDDB CACHE: Storing ${routes.length} routes...`);
                const startTime = performance.now();
                
                // Try IndexedDB first (250MB+ capacity)
                const db = await initIndexedDB();
                
                if (db) {
                    await cacheRoutesIndexedDB(db, routes);
                } else {
                    // Fallback to localStorage with limits
                    await cacheRoutesLocalStorage(routes);
                }
                
                const cacheTime = performance.now() - startTime;
                console.log(`‚úÖ Cache operation completed in ${cacheTime.toFixed(2)}ms`);
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Cache save failed:', error);
                await clearRouteCache();
            }
        }

        async function cacheRoutesIndexedDB(db, routes) {
            // Enhanced compression: Keep more GPS points but compress with better algorithm
            const compressedRoutes = routes.map(route => ({
                id: route.id,
                name: route.name,
                type: route.type,
                distance: route.distance,
                time: route.time,
                date: route.date,
                location: route.location,
                // IMPROVED: Keep every 5th point instead of 10th (better quality + still efficient)
                coordinates: route.coordinates ? route.coordinates.filter((_, i) => i % 5 === 0) : null,
                // Cache additional useful data since we have space
                trainer: route.trainer,
                sport_type: route.sport_type,
                manual: route.manual,
                workout_type: route.workout_type
            }));
            
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            
            // Store routes data
            await new Promise((resolve, reject) => {
                const request = store.put({
                    key: 'strava_routes_cache',
                    data: compressedRoutes,
                    timestamp: Date.now(),
                    version: DB_VERSION,
                    routeCount: routes.length
                });
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
            
            const dataSizeKB = JSON.stringify(compressedRoutes).length / 1024;
            console.log(`üíæ IndexedDB: Cached ${routes.length} routes (${dataSizeKB.toFixed(0)}KB) - NO SIZE LIMITS! üéâ`);
        }

        async function cacheRoutesLocalStorage(routes) {
            // Fallback: Use localStorage with original compression
            const lightRoutes = routes.map(route => ({
                id: route.id,
                name: route.name,
                type: route.type,
                distance: route.distance,
                time: route.time,
                date: route.date,
                location: route.location,
                coordinates: route.coordinates ? route.coordinates.filter((_, i) => i % 10 === 0) : null
            }));
            
            const jsonData = JSON.stringify(lightRoutes);
            const sizeKB = jsonData.length / 1024;
            
            if (sizeKB > 5000) {
                console.warn(`‚ö†Ô∏è LocalStorage fallback: Too large (${sizeKB.toFixed(0)}KB), using first 200 routes`);
                const reducedRoutes = lightRoutes.slice(0, 200); // Increased from 100
                localStorage.setItem('strava_routes_cache', JSON.stringify(reducedRoutes));
                console.log(`üíæ LocalStorage: Cached 200 routes (size limit fallback)`);
            } else {
                localStorage.setItem('strava_routes_cache', jsonData);
                console.log(`üíæ LocalStorage: Cached ${routes.length} routes (${sizeKB.toFixed(0)}KB)`);
            }
            
            localStorage.setItem('strava_routes_cache_timestamp', Date.now().toString());
        }
        
        async function clearRouteCache() {
            console.log('üßπ Clearing all route caches...');
            
            // Clear IndexedDB
            try {
                const db = await initIndexedDB();
                if (db) {
                    await clearCachedRoutesIndexedDB(db);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è IndexedDB clear error:', error);
            }
            
            // Clear localStorage
            clearCachedRoutesLocalStorage();
            console.log('‚úÖ All caches cleared');
        }

        async function clearCachedRoutesIndexedDB(db) {
            try {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                
                await new Promise((resolve, reject) => {
                    const request = store.delete('strava_routes_cache');
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
                
                console.log('üóëÔ∏è IndexedDB cache cleared');
            } catch (error) {
                console.warn('‚ö†Ô∏è IndexedDB clear error:', error);
            }
        }

        function clearCachedRoutesLocalStorage() {
            localStorage.removeItem('strava_routes_cache');
            localStorage.removeItem('strava_routes_cache_timestamp');
            console.log('üóëÔ∏è LocalStorage cache cleared');
        }

        // Proactive cache validation and cleanup (Strava API compliance)
        function validateCacheExpiration() {
            try {
                const cacheTimestamp = localStorage.getItem('strava_routes_cache_timestamp');
                if (cacheTimestamp) {
                    const cacheAge = Date.now() - parseInt(cacheTimestamp);
                    const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days per Strava API requirements
                    
                    if (cacheAge >= maxAge) {
                        console.log('üïí Proactive cache cleanup: 7-day expiration reached');
                        clearRouteCache();
                        return false; // Cache was expired and cleared
                    }
                    
                    const ageDays = Math.floor(cacheAge / (24 * 60 * 60 * 1000));
                    const ageHours = Math.floor((cacheAge % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
                    console.log(`‚úÖ Cache valid: ${ageDays}d ${ageHours}h old (max 7 days)`);
                    return true; // Cache is still valid
                }
                return false; // No cache exists
            } catch (error) {
                console.warn('‚ö†Ô∏è Cache validation failed:', error);
                clearRouteCache(); // Clear corrupted cache
                return false;
            }
        }
        
        // Progressive route loading (show first 100, then continue)
        async function loadStravaRoutes() {
            try {
                console.log('üö¥‚Äç‚ôÇÔ∏è OPTIMIZED Loading with PROGRESSIVE LOADING and CACHING...');
                
                // Check cache first - avoid reloading same routes
                const cachedRoutes = getCachedRoutes();
                if (cachedRoutes && cachedRoutes.length > 0) {
                    console.log(`‚ö° FAST LOAD: Using ${cachedRoutes.length} cached routes!`);
                    // TODO: Start background loading for any new routes
                    return cachedRoutes;
                }
                
                console.log('üîç DEBUG: No cache, fetching fresh data...');
                console.log('üîç DEBUG: Access token exists:', !!stravaAPI.accessToken);
                console.log('üîç DEBUG: Access token length:', stravaAPI.accessToken ? stravaAPI.accessToken.length : 0);
                
                // IMPORTANT: Handle OAuth callback FIRST (before checking authentication)
                console.log('üîç DEBUG: Checking for OAuth callback before auth check...');
                await stravaAPI.handleAuthCallback();
                
                // Now check if authenticated (after potentially processing callback)
                if (!stravaAPI.isAuthenticated()) {
                    console.log('üìã Not authenticated with Strava - showing sample data for demonstration');
                    console.log('üîó Users can click "Connect to Strava" to load their real routes');
                    return generateSampleRoutes();
                }
                
                // üöÄ QUICK STATS LOAD: Get total distances immediately!
                try {
                    console.log('‚ö° PRIORITY: Loading Luke\'s total stats first...');
                    const quickStats = await stravaAPI.getAthleteStats();
                    
                    if (quickStats) {
                        // Update stats display immediately with Strava totals
                        updateStatsFromStravaData(quickStats);
                        console.log('‚úÖ Quick stats loaded and displayed!');
                    }
                } catch (statsError) {
                    console.warn('‚ö†Ô∏è Could not load quick stats:', statsError.message);
                }
                
                // Load RECENT activities only (optimized for speed)
                const allActivities = [];
                let page = 1;
                let hasMorePages = true;
                const perPage = 100; // Reduced per request
                const maxRoutes = 500; // COMPROMISE: Load 500 recent routes (good balance)
                const initialBatch = 100; // Show first 100 FAST, then continue in background
                
                // Update UI to show progress
                updateLoadingStatus('Loading activities from Strava...');
                
                while (hasMorePages) {
                    console.log(`üìÑ Loading page ${page} of activities...`);
                    
                    try {
                        const activities = await stravaAPI.getActivities(page, perPage);
                        console.log(`üîç DEBUG: API returned ${activities.length} activities for page ${page}`);
                        
                        // Quick activity validation (no detailed logging)
                        const validActivities = activities.filter(a => a.name && a.distance > 0).length;
                        if (page === 1) console.log(`üöÄ Page ${page}: ${validActivities}/${activities.length} valid activities`);
                        
                        if (activities.length === 0) {
                            hasMorePages = false;
                            console.log('‚úÖ Reached end of activities');
                        } else {
                            allActivities.push(...activities);
                            console.log(`üìä Loaded ${activities.length} activities from page ${page} (Total: ${allActivities.length})`);
                            
                            // Update progress
                            updateLoadingStatus(`Loaded ${allActivities.length} activities...`);
                            
                            // SPEED OPTIMIZATION: Stop if we have enough routes
                            if (allActivities.length >= maxRoutes) {
                                hasMorePages = false;
                                console.log(`‚ö° SPEED LIMIT: Stopping at ${allActivities.length} routes (max: ${maxRoutes})`);
                            }
                            // If we got less than perPage activities, we're on the last page
                            else if (activities.length < perPage) {
                                hasMorePages = false;
                            } else {
                                page++;
                            }
                            
                            // Rate limiting between pages
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    } catch (pageError) {
                        console.warn(`‚ö†Ô∏è Could not load page ${page}:`, pageError.message);
                        hasMorePages = false;
                        
                        // If it's an auth error, handle gracefully
                        if (pageError.message.includes('token expired') || pageError.message.includes('401') || pageError.message.includes('Not authenticated')) {
                            console.log('üîÑ Authentication needed - user can connect via button');
                            stravaAPI.clearTokens();
                            // Don't throw error - just return empty activities list for graceful fallback
                            break;
                        }
                    }
                }
                
                console.log(`üéØ TOTAL ACTIVITIES FOUND: ${allActivities.length}`);
                updateLoadingStatus(`Processing ${allActivities.length} activities...`);
                
                // üöÄ CRITICAL FIX #1: Use Web Worker for background route processing
                console.log('üîß CRITICAL FIX #1: Using Web Worker for background processing...');
                updateLoadingStatus(`Processing ${allActivities.length} activities with Web Worker...`);
                
                // Process routes using Web Worker to prevent UI freezing
                const routes = await processRoutesWithWorker(allActivities, (progress) => {
                    // Progress callback for UI updates
                    const percentage = Math.round((progress.processed / progress.total) * 100);
                    updateLoadingStatus(`Processing ${progress.processed}/${progress.total} activities (${percentage}%)...`);
                });
                
                // OPTIMIZATION SUMMARY
                const gpsRoutes = routes.filter(r => r.coordinates?.length > 0).length;
                const runRoutes = routes.filter(r => r.type === 'running').length;
                const cycleRoutes = routes.filter(r => r.type === 'cycling').length;
                
                console.log(`üöÄ OPTIMIZED LOAD COMPLETE: ${routes.length} routes (${gpsRoutes} with GPS)`);
                console.log(`üìä Run: ${runRoutes} | Cycle: ${cycleRoutes} | Avg size: ~2KB per route`);
                
                updateLoadingStatus(`‚úÖ Ultra-fast load: ${routes.length} routes!`);
                
                // SMART CACHING: Save routes for next time (size-conscious)
                cacheRoutes(routes);
                
                return routes;
                
            } catch (error) {
                console.error('‚ùå Failed to load Strava routes:', error);
                console.log('üîÑ Falling back to sample data');
                updateLoadingStatus('‚ùå Failed to load Strava data - using samples');
                return generateSampleRoutes();
            }
        }
        
        // Update loading status in UI
        function updateLoadingStatus(message) {
            const loadingText = document.querySelector('.loading-text');
            if (loadingText) {
                loadingText.textContent = message;
            }
            console.log(`üì± Status: ${message}`);
        }
        
        // Add Strava authentication UI to sidebar
        function addStravaAuthButton() {
            const sidebarHeader = document.querySelector('.sidebar-header');
            
            if (!stravaAPI.isAuthenticated()) {
                const authButton = document.createElement('button');
                authButton.className = 'strava-auth-btn';
                authButton.innerHTML = 'üîó Connect to Strava';
                authButton.style.cssText = `
                    background: #fc4c02;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 4px;
                    cursor: pointer;
                    margin-top: 10px;
                    font-size: 14px;
                `;
                
                authButton.addEventListener('click', () => {
                    stravaAPI.authenticate();
                });
                
                sidebarHeader.appendChild(authButton);
            } else {
                const connectedStatus = document.createElement('div');
                connectedStatus.innerHTML = '‚úÖ Connected to Strava';
                connectedStatus.style.cssText = `
                    color: #4ade80;
                    font-size: 14px;
                    margin-top: 10px;
                `;
                sidebarHeader.appendChild(connectedStatus);
            }
        }

        // Sample route data (will be replaced with Luke's real Strava data)
        // UPDATED: ~10,000 mile (16,093 km) total for testing epic journey animation
        const generateSampleRoutes = () => {
            return [
                {
                    id: '1',
                    name: 'Epic Cross-Country Marathon',
                    type: 'running',
                    distance: 2500.5,
                    time: 45,
                    location: 'New York, NY',
                    date: '2024-09-01',
                    coordinates: [
                        [-73.9583, 40.8021], // North entrance
                        [-73.9551, 40.7967], // Harlem Meer
                        [-73.9497, 40.7851], // Great Lawn
                        [-73.9542, 40.7648], // The Mall
                        [-73.9721, 40.7489], // Wollman Rink
                        [-73.9818, 40.7589], // Sheep Meadow
                        [-73.9792, 40.7731], // Strawberry Fields
                        [-73.9583, 40.8021]  // Back to start
                    ]
                },
                {
                    id: '2',
                    name: 'Transcontinental Cycling Adventure',
                    type: 'cycling',
                    distance: 4000.2,
                    time: 125,
                    location: 'San Francisco, CA',
                    date: '2024-08-28',
                    coordinates: [
                        [-122.4194, 37.7749], // Downtown SF
                        [-122.4286, 37.7849], // Presidio approach
                        [-122.4686, 37.8099], // Golden Gate Bridge south
                        [-122.4786, 37.8199], // Golden Gate Bridge north
                        [-122.4886, 37.8299], // Marin Headlands
                        [-122.4986, 37.8199], // Vista Point
                        [-122.4786, 37.8099], // Bridge return
                        [-122.4286, 37.7849], // Back through Presidio
                        [-122.4194, 37.7749]  // Back to downtown
                    ]
                },
                {
                    id: '3',
                    name: 'European Ultra Marathon Circuit',
                    type: 'running',
                    distance: 3200.1,
                    time: 105,
                    location: 'London, UK', 
                    date: '2024-09-03',
                    coordinates: [
                        [-0.1276, 51.5074], // Westminster Bridge
                        [-0.1031, 51.5074], // London Eye
                        [-0.0761, 51.5055], // Blackfriars Bridge
                        [-0.0278, 51.5074], // Tower Bridge
                        [-0.0178, 51.5074], // Butler's Wharf
                        [0.0022, 51.4994],  // Greenwich
                        [-0.0178, 51.5074], // Return Butler's Wharf
                        [-0.0761, 51.5055], // Return Blackfriars
                        [-0.1031, 51.5074], // Return London Eye
                        [-0.1276, 51.5074]  // Return Westminster
                    ]
                },
                {
                    id: '4', 
                    name: 'Pacific Rim Mega Cycling Tour',
                    type: 'cycling',
                    distance: 4500.8,
                    time: 180,
                    location: 'Monterey, CA',
                    date: '2024-08-25',
                    coordinates: [
                        [-121.8947, 36.6002], // Monterey
                        [-121.9058, 36.5527], // 17-Mile Drive start
                        [-121.9258, 36.5127], // Pebble Beach
                        [-121.9458, 36.4727], // Lone Cypress
                        [-121.9658, 36.4327], // Bird Rock
                        [-121.9358, 36.3927], // Carmel
                        [-121.9158, 36.4327], // Carmel Valley
                        [-121.8958, 36.4727], // Point Lobos
                        [-121.8947, 36.6002]  // Back to Monterey
                    ]
                },
                {
                    id: '5',
                    name: 'Around-the-World Running Challenge',
                    type: 'running', 
                    distance: 1892.2,
                    time: 35,
                    location: 'London, UK',
                    date: '2024-09-04',
                    coordinates: [
                        [-0.1652, 51.5074], // Hyde Park Corner
                        [-0.1552, 51.5174], // Speaker's Corner
                        [-0.1752, 51.5174], // Lancaster Gate
                        [-0.1852, 51.5074], // Kensington Gardens
                        [-0.1752, 51.4974], // Albert Memorial
                        [-0.1652, 51.4974], // South Carriage Drive
                        [-0.1652, 51.5074]  // Back to start
                    ]
                }
            ];
        };

        // Initialize the application with robust imagery fallback system
        async function initializeApp() {
            try {
                console.log('üåç =================================');
                console.log('üåç STARTING LUKE ROUTE GLOBE DEBUG');
                console.log('üåç =================================');
                console.log('üîç Debug: generateSampleRoutes called');
                sampleRoutes = generateSampleRoutes();
                console.log('üîç Debug: Sample routes generated:', sampleRoutes.length, 'routes');
                
                console.log('üîç Debug: Cesium Ion token status:', Cesium.Ion.defaultAccessToken ? 'SET' : 'NOT SET');
                console.log('üîç Debug: Cesium version:', Cesium.VERSION || 'Unknown');
                
                // Create multiple imagery provider strategies
                let imageryProvider = null;
                console.log('üîç Debug: Starting imagery provider selection...');
                
                try {
                    // STRATEGY 1: Ion Asset ID 3 (Bing Maps On Demand - High Resolution)
                    console.log('üó∫Ô∏è DEBUG: Starting Strategy 1 - Ion Asset ID 3 (Bing Maps)...');
                    console.log('üîç Debug: Using Ion token for high-res Bing Maps access...');
                    console.log('üîç Debug: Asset ID 3 = Bing Maps On Demand with street-level detail...');
                    
                    imageryProvider = await Cesium.IonImageryProvider.fromAssetId(3, {
                        maximumLevel: 20  // Street-level zoom for high fidelity
                    });
                    console.log('‚úÖ DEBUG: Strategy 1 SUCCESS - Ion Asset ID 3 loaded');
                    console.log('üîç Debug: Provider type:', imageryProvider.constructor.name);
                    console.log('üîç Debug: Provider ready:', imageryProvider.ready);
                    
                } catch (cesiumBingError) {
                    console.error('‚ùå DEBUG: Strategy 1 FAILED - Direct Bing Maps API');
                    console.error('üîç Debug: Error message:', cesiumBingError.message);
                    console.error('üîç Debug: Error stack:', cesiumBingError.stack);
                    
                    try {
                        // STRATEGY 2: Ion Asset ID 2 (Sentinel-2 Satellite - High Resolution)
                        console.log('üó∫Ô∏è DEBUG: Attempting Strategy 2 - Ion Asset ID 2 (Sentinel-2)...');
                        console.log('üîç Debug: Sentinel-2 provides 10m resolution satellite imagery...');
                        
                        imageryProvider = await Cesium.IonImageryProvider.fromAssetId(2, {
                            maximumLevel: 18  // High-resolution satellite imagery
                        });
                        console.log('‚úÖ Strategy 2: Ion Asset ID 2 (Sentinel-2) loaded successfully');
                        
                    } catch (bingError) {
                        console.warn('‚ö†Ô∏è Strategy 2 failed:', bingError.message);
                    
                        try {
                            // STRATEGY 3: Natural Earth II (local Cesium imagery - no Ion calls)
                            console.log('üåç Attempting Natural Earth II (Strategy 3)...');
                            imageryProvider = new Cesium.TileMapServiceImageryProvider({
                                url: Cesium.buildModuleUrl('Assets/Textures/NaturalEarthII/')
                            });
                            console.log('‚úÖ Strategy 3: Natural Earth II loaded successfully');
                            
                        } catch (cesiumIonError) {
                            console.warn('‚ö†Ô∏è Strategy 3 failed:', cesiumIonError.message);
                        
                            try {
                                // STRATEGY 4: ESRI World Imagery (high quality, no account needed)
                                console.log('üõ∞Ô∏è Attempting ESRI World Imagery (Strategy 4)...');
                                imageryProvider = await Cesium.ArcGisMapServerImageryProvider.fromUrl('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer');
                                console.log('‚úÖ Strategy 4: ESRI World Imagery loaded successfully');
                                
                            } catch (esriError) {
                                console.warn('‚ö†Ô∏è Strategy 4 failed:', esriError.message);
                                
                                // STRATEGY 5: OpenStreetMap (always works)
                                console.log('üó∫Ô∏è Using OpenStreetMap fallback (Strategy 5)...');
                                imageryProvider = new Cesium.OpenStreetMapImageryProvider({
                                    url: 'https://tile.openstreetmap.org/',
                                    maximumLevel: 19
                                });
                                console.log('‚úÖ Strategy 5: OpenStreetMap fallback ready');
                            }
                        }
                    }
                }
                
                if (!imageryProvider) {
                    throw new Error('All imagery provider strategies failed');
                }
                
                // Create Cesium viewer with simplified, reliable configuration
                console.log('üåç =================================');
                console.log('üåç DEBUG: CREATING CESIUM VIEWER');
                console.log('üåç =================================');
                console.log('üîç Debug: Final imagery provider type:', imageryProvider.constructor.name);
                console.log('üîç Debug: Final imagery provider ready:', imageryProvider.ready);
                console.log('üîç Debug: cesiumContainer element exists:', !!document.getElementById('cesiumContainer'));
                console.log('üîç Debug: About to create Viewer with configuration...');
                console.log('üîç Debug: Creating terrain provider...');
                console.log('üîç Debug: Using Ion Asset ID 1 (Cesium World Terrain) directly...');
                
                let terrainProvider;
                try {
                    // üö® FIX: Try Ion Asset ID 1 but with better error handling
                    console.log('üîß IMPROVED: Trying Ion terrain with robust fallback...');
                    terrainProvider = await Cesium.CesiumTerrainProvider.fromIonAssetId(1);
                    console.log('‚úÖ Debug: Ion Asset ID 1 terrain loaded successfully');
                } catch (terrainError) {
                    console.warn('‚ö†Ô∏è Ion terrain failed (404 endpoint common), using ellipsoid:', terrainError.message);
                    // üö® FIX: Use ellipsoid terrain immediately when Ion fails (prevents crashes)
                    terrainProvider = new Cesium.EllipsoidTerrainProvider();
                    console.log('üîß FIXED: Using ellipsoid terrain provider (reliable fallback)');
                }
                
                viewer = new Cesium.Viewer('cesiumContainer', {
                    // Imagery
                    imageryProvider: imageryProvider,
                    
                    // Use the terrain provider we just created
                    terrainProvider: terrainProvider,
                    
                    // Rendering
                    requestRenderMode: false,
                    maximumRenderTimeChange: Infinity,
                    
                    // Disable UI elements for clean look
                    baseLayerPicker: false,
                    fullscreenButton: false,
                    geocoder: false,
                    homeButton: false,
                    sceneModePicker: false,
                    selectionIndicator: false,
                    timeline: false,
                    navigationHelpButton: false,
                    animation: false,
                    creditContainer: document.createElement('div'),
                    
                    // Enhanced scene settings
                    contextOptions: {
                        requestWebGL2: true,
                        alpha: false
                    },
                    useBrowserRecommendedResolution: true
                });
                
                console.log('‚úÖ DEBUG: Cesium viewer created successfully!');
                console.log('üîç Debug: Viewer object exists:', !!viewer);
                console.log('üîç Debug: Viewer scene exists:', !!viewer.scene);
                console.log('üîç Debug: Viewer globe exists:', !!viewer.scene.globe);
                console.log('üîç Debug: Imagery layers count:', viewer.scene.imageryLayers.length);
                
                // CRITICAL DEBUG: Check if imagery provider is actually in the viewer
                if (viewer.scene.imageryLayers.length > 0) {
                    const layer0 = viewer.scene.imageryLayers.get(0);
                    console.log('‚úÖ Debug: Layer 0 exists - provider:', layer0.imageryProvider.constructor.name);
                    console.log('üîç Debug: Layer 0 ready:', layer0.imageryProvider.ready);
                    console.log('üîç Debug: Layer 0 alpha:', layer0.alpha);
                    console.log('üîç Debug: Layer 0 show:', layer0.show);
                } else {
                    console.warn('‚ö†Ô∏è No imagery layers detected - manually adding provider...');
                    console.log('üîß FIXING: Adding imagery provider to viewer layers...');
                    
                    // Manually add the imagery provider to viewer layers
                    try {
                        if (imageryProvider) {
                            const addedLayer = viewer.scene.imageryLayers.addImageryProvider(imageryProvider);
                            console.log('‚úÖ FIXED: Imagery provider manually added to viewer');
                            console.log('üîç Fixed layers count:', viewer.scene.imageryLayers.length);
                        } else {
                            // Last resort: Add OpenStreetMap
                            const osmProvider = new Cesium.OpenStreetMapImageryProvider({
                                url: 'https://tile.openstreetmap.org/'
                            });
                            const osmLayer = viewer.scene.imageryLayers.addImageryProvider(osmProvider);
                            console.log('üó∫Ô∏è FALLBACK: Added OpenStreetMap as imagery provider');
                        }
                        viewer.scene.requestRender();
                    } catch (fixError) {
                        console.error('‚ùå Fix failed:', fixError.message);
                        // Add OpenStreetMap as absolute fallback
                        const osmProvider = new Cesium.OpenStreetMapImageryProvider({
                            url: 'https://tile.openstreetmap.org/'
                        });
                        viewer.scene.imageryLayers.addImageryProvider(osmProvider);
                        console.log('‚úÖ FALLBACK: OpenStreetMap added');
                    }
                }

                // Configure the globe for optimal satellite imagery performance
                const globe = viewer.scene.globe;
                globe.enableLighting = false; // Better for satellite imagery
                globe.dynamicAtmosphereLighting = false;
                globe.atmosphereHueSaturationShift = new Cesium.Cartesian3(0.0, 0.0, 0.0);
                
                // Performance-optimized settings based on Cesium best practices
                globe.maximumScreenSpaceError = 2; // Balanced quality/performance (was 1.5)
                globe.tileCacheSize = 100; // Optimized cache size
                globe.loadingDescendantLimit = 20;
                globe.preloadAncestors = true; // Improved loading
                globe.preloadSiblings = true; // Better tile management
                
                // Configure scene for optimal satellite viewing performance
                const scene = viewer.scene;
                scene.fog.enabled = false; // Clear satellite view
                scene.backgroundColor = Cesium.Color.BLACK;
                scene.fxaa = true;
                scene.gamma = 1.0;
                
                // Simplified scene configuration for reliable imagery display
                scene.globe.show = true; // Ensure globe is visible
                scene.skyBox.show = true; // Ensure skybox is visible
                
                // Basic performance settings without complex optimizations
                scene.fxaa = true; // Keep anti-aliasing
                scene.fog.enabled = false; // Clear satellite view
                
                // Configure camera controls for detailed zoom with STRONG drift prevention
                const controller = scene.screenSpaceCameraController;
                controller.enableCollisionDetection = false; // Performance improvement
                controller.minimumZoomDistance = 0.5; // Allow very close zoom
                controller.maximumZoomDistance = 20000000.0; // STRICTER: Further reduced max zoom
                
                // AGGRESSIVE camera drift prevention
                controller.enableTilt = true;
                controller.enableLook = false; // Disable free look completely
                controller.enableTranslate = true;
                controller.enableZoom = true;
                controller.enableRotate = true;
                
                // IMPROVED: Add real-time camera constraint to prevent drift
                viewer.camera.moveEnd.addEventListener(() => {
                    const cameraHeight = viewer.camera.positionCartographic.height;
                    const cameraPosition = viewer.camera.position;
                    const earthCenter = Cesium.Cartesian3.ZERO;
                    const distanceToEarth = Cesium.Cartesian3.distance(cameraPosition, earthCenter);
                    
                    // If camera is getting too far from Earth, constrain it
                    if (cameraHeight > 25000000 || distanceToEarth > 35000000) {
                        console.log('üéØ Preventing camera drift - constraining zoom');
                        // FIXED: Use Earth-centered view helper
                        ensureEarthCenteredView();
                    }
                });
                
                // ADDITIONAL: Prevent extreme zoom out with scroll wheel and trackpad
                controller.zoomEventTypes = [
                    Cesium.CameraEventType.WHEEL,
                    Cesium.CameraEventType.PINCH
                ];
                
                // MAC TRACKPAD SPECIFIC: Add gesture event monitoring
                const canvas = viewer.canvas;
                canvas.addEventListener('wheel', (event) => {
                    // Detect rapid Mac trackpad zoom-out gestures
                    if (Math.abs(event.deltaY) > 10) { // Large delta indicates rapid gesture
                        const currentHeight = viewer.camera.positionCartographic.height;
                        if (currentHeight > 12000000) {
                            console.log('üö´ BLOCKING rapid Mac trackpad zoom-out');
                            event.preventDefault();
                            event.stopPropagation();
                            
                            // Immediate correction
                            setTimeout(() => {
                                ensureEarthCenteredView();
                            }, 10);
                        }
                    }
                }, { passive: false });
                
                // AGGRESSIVE: Override zoom behavior with Mac trackpad protection
                const originalZoom = controller._zoom3D;
                controller._zoom3D = function(startPosition, movement) {
                    // Get current camera height and position before zoom
                    const beforeHeight = viewer.camera.positionCartographic.height;
                    const beforePitch = viewer.camera.pitch;
                    
                    // CRITICAL: Block zoom if already too high or at wrong angle
                    if (beforeHeight > 15000000) {
                        console.log('üö´ BLOCKING rapid zoom - height limit reached');
                        ensureEarthCenteredView();
                        return; // Block the zoom entirely
                    }
                    
                    // Allow zoom but monitor result
                    const result = originalZoom.call(this, startPosition, movement);
                    
                    // IMMEDIATE constraint check after zoom
                    const afterHeight = viewer.camera.positionCartographic.height;
                    const afterPitch = viewer.camera.pitch;
                    
                    // If zoom caused problems, immediately correct
                    if (afterHeight > 18000000 || afterPitch > -Math.PI/4) {
                        console.log('üö´ CORRECTING problematic zoom result');
                        setTimeout(() => {
                            ensureEarthCenteredView();
                        }, 1); // Immediate correction
                    }
                    
                    return result;
                };
                
                // ENHANCED: High-frequency monitoring for Mac trackpad gestures
                let lastValidCameraHeight = 15000000;
                const earthRadius = 6371000; // Earth radius in meters
                let lastConstraintTime = 0;
                
                // Add real-time camera monitoring (higher frequency for trackpad)
                const monitorCamera = () => {
                    if (isAnimationInProgress) return; // Don't interfere with animations
                    
                    const now = Date.now();
                    const currentHeight = viewer.camera.positionCartographic.height;
                    const currentPitch = viewer.camera.pitch;
                    
                    // RAPID CORRECTION for trackpad zoom-outs
                    if (currentHeight > 18000000 || currentPitch > -Math.PI/6) {
                        // Throttle corrections to prevent fighting with user AND avoid marker recreation conflicts
                        if (now - lastConstraintTime > 1500) { // Increased to 1.5 seconds to avoid marker conflicts
                            console.log('üöë EMERGENCY: Rapid trackpad correction needed');
                            ensureEarthCenteredView();
                            lastConstraintTime = now;
                        }
                    }
                    
                    requestAnimationFrame(monitorCamera);
                };
                monitorCamera(); // Start real-time monitoring
                
                setInterval(() => {
                    try {
                        const camera = viewer.camera;
                        const cameraCartographic = camera.positionCartographic;
                        const cameraHeight = cameraCartographic.height;
                        
                        // If camera height is reasonable, store it as last valid
                        if (cameraHeight > 100 && cameraHeight < 100000000) {
                            lastValidCameraHeight = cameraHeight;
                        }
                        
                        // Check if camera has drifted too far or is pointing away from Earth
                        const cameraPosition = camera.position;
                        const earthCenter = Cesium.Cartesian3.ZERO;
                        const directionToEarth = Cesium.Cartesian3.subtract(earthCenter, cameraPosition, new Cesium.Cartesian3());
                        const distanceToEarth = Cesium.Cartesian3.magnitude(directionToEarth);
                        
                        // Normalize direction to Earth
                        Cesium.Cartesian3.normalize(directionToEarth, directionToEarth);
                        
                        // Check if camera is pointing away from Earth (dot product < 0 means opposite directions)
                        const cameraDirection = camera.direction;
                        const dotProduct = Cesium.Cartesian3.dot(cameraDirection, directionToEarth);
                        
                        // If camera is too far, pointing away, or height is invalid, reset it
                        if (distanceToEarth > earthRadius + 100000000 || dotProduct < -0.1 || cameraHeight < 0 || cameraHeight > 200000000) {
                            console.log('‚ö†Ô∏è CAMERA DRIFT DETECTED - Resetting to safe position');
                            console.log(`‚ö†Ô∏è - Distance to Earth: ${(distanceToEarth/1000).toFixed(0)}km`);
                            console.log(`‚ö†Ô∏è - Dot product: ${dotProduct.toFixed(3)}`);
                            console.log(`‚ö†Ô∏è - Camera height: ${(cameraHeight/1000).toFixed(0)}km`);
                            
                            // FIXED: Use Earth-centered view helper for consistency
                            ensureEarthCenteredView();
                            
                            viewer.scene.requestRender();
                        }
                        
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Camera monitoring error:', error);
                    }
                }, 100); // Check every 100ms
                
                // High-resolution rendering with performance balance
                viewer.resolutionScale = 1.0;
                viewer.useBrowserRecommendedResolution = false;
                
                // WebGL optimization
                const gl = scene.context._gl;
                if (gl.getExtension('EXT_texture_filter_anisotropic')) {
                    // Enable anisotropic filtering for better imagery quality
                    console.log('Anisotropic filtering enabled for better satellite imagery');
                }
                
                // FIXED: Set initial view with proper perpendicular angle
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(-98.5795, 39.8283, 15000000.0),
                    orientation: {
                        heading: 0.0,
                        pitch: -Math.PI / 2, // FIXED: 90¬∞ straight down instead of -1.57
                        roll: 0.0
                    }
                });

                // Force initial render with performance monitoring
                viewer.scene.requestRender();
                console.log('Initial render requested');

                // Wait for globe to be ready with timeout
                await new Promise((resolve) => {
                    let resolved = false;
                    const removeCallback = globe.tileLoadProgressEvent.addEventListener((queuedTileCount) => {
                        console.log(`Tiles loading: ${queuedTileCount} remaining`);
                        if (queuedTileCount === 0 && !resolved) {
                            resolved = true;
                            removeCallback();
                            resolve();
                        }
                    });
                    
                    // Timeout fallback to prevent infinite loading
                    setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            removeCallback();
                            console.log('Globe loading timeout - proceeding anyway');
                            resolve();
                        }
                    }, 10000); // 10 second timeout
                });

                // Hide loading screen after globe is ready
                setTimeout(() => {
                    document.getElementById('loadingScreen').classList.add('hidden');
                    viewer.scene.requestRender(); // Ensure final render
                    console.log('Application fully loaded with optimized performance');
                }, 1000);

                // Initialize UI with Strava integration
                await initializeRoutes();
                addStravaAuthButton();
                updateStats();
                setupEventListeners();
                
                // Auto-load Luke's face if enabled
                if (AUTO_LOAD_LUKES_FACE) {
                    console.log('ü§Ø Auto-loading Luke\'s face...');
                    if (IMAGE_METHOD === 4) {
                        // Load asynchronously from file
                        const lukesImage = await loadLukesImageFromFile();
                        console.log('üì∑ Using Luke\'s image from file:', lukesImage.substring(0, 50) + '...');
                        setLukesHeadImage(lukesImage);
                    } else if (IMAGE_METHOD === 3) {
                        // METHOD 3: Try multiple filename variations
                        console.log('üîç METHOD 3: Finding correct image filename...');
                        const workingImageFile = await findWorkingImageFile();
                        console.log('üì∑ Using Luke\'s image file:', workingImageFile);
                        setLukesHeadImage(workingImageFile);
                    } else {
                        // Use other synchronous methods (1, 2, 5)
                        const lukesImage = getLukesImage();
                        if (lukesImage === 'PASTE_LUKES_BASE64_DATA_HERE_INCLUDING_DATA_IMAGE_PREFIX') {
                            console.log('‚ö†Ô∏è Hardcoded base64 placeholder detected - Luke\'s face not pasted yet');
                            console.log('üìã To add Luke\'s face, paste base64 data on line 382');
                        } else {
                            console.log('üì∑ Using Luke\'s image:', lukesImage);
                            setLukesHeadImage(lukesImage);
                        }
                    }
                }
                
                console.log('‚úÖ Luke Route Globe initialized successfully!');
                
            } catch (error) {
                console.error('‚ùå Critical initialization error:', error);
                
                // Display error message to user
                const loadingText = document.querySelector('.loading-text');
                if (loadingText) {
                    loadingText.textContent = '‚ùå Error loading globe. Please refresh the page.';
                }
                
                // Still try to hide loading screen after delay
                setTimeout(() => {
                    const loadingScreen = document.getElementById('loadingScreen');
                    if (loadingScreen) {
                        loadingScreen.classList.add('hidden');
                    }
                }, 3000);
            }
        }
        
        // Geographic clustering functions for Airbnb-style markers
        function calculateDistance(lat1, lon1, lat2, lon2) {
            // Haversine formula for distance between two points
            const R = 6371; // Earth's radius in kilometers
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function clusterRoutes(routes, maxDistance = 50) {
            // Group routes by geographic proximity (like Airbnb)
            const clusters = [];
            const processed = new Set();
            
            routes.forEach((route, index) => {
                if (processed.has(index) || !route.coordinates || route.coordinates.length === 0) return;
                
                const cluster = {
                    routes: [route],
                    centerLat: route.coordinates[0][1], // lat from first coordinate
                    centerLng: route.coordinates[0][0], // lng from first coordinate
                    city: route.location
                };
                
                // Find nearby routes to cluster
                routes.forEach((otherRoute, otherIndex) => {
                    if (processed.has(otherIndex) || otherIndex === index || 
                        !otherRoute.coordinates || otherRoute.coordinates.length === 0) return;
                        
                    const distance = calculateDistance(
                        cluster.centerLat, cluster.centerLng,
                        otherRoute.coordinates[0][1], otherRoute.coordinates[0][0]
                    );
                    
                    if (distance <= maxDistance) {
                        cluster.routes.push(otherRoute);
                        processed.add(otherIndex);
                    }
                });
                
                processed.add(index);
                clusters.push(cluster);
            });
            
            return clusters;
        }
        
        // THROTTLING: Prevent rapid marker recreation that causes disappearing markers
        let lastMarkerCreation = 0;
        const MARKER_THROTTLE_MS = 1000; // Minimum 1 second between recreations

        // PERFORMANCE OPTIMIZATION: Get geographically diverse routes to prevent clustering overload
        function getGeographicallyDiverseRoutes(routes, maxCount) {
            if (routes.length <= maxCount) return routes;
            
            try {
                // Simple geographic diversity: spread routes across different coordinate areas
                const gridSize = Math.ceil(Math.sqrt(maxCount)); // Create a grid
                const routesByGrid = new Map();
                
                routes.forEach(route => {
                    if (route.coordinates && route.coordinates.length > 0) {
                        // Get first coordinate for geographic binning
                        const [lng, lat] = route.coordinates[0];
                        const gridX = Math.floor((lng + 180) / (360 / gridSize));
                        const gridY = Math.floor((lat + 90) / (180 / gridSize));
                        const gridKey = `${gridX},${gridY}`;
                        
                        if (!routesByGrid.has(gridKey)) {
                            routesByGrid.set(gridKey, []);
                        }
                        routesByGrid.get(gridKey).push(route);
                    }
                });
                
                // Take one route from each grid cell
                const diverseRoutes = [];
                for (const [gridKey, gridRoutes] of routesByGrid.entries()) {
                    if (diverseRoutes.length < maxCount) {
                        // Take the most recent route from this geographic area
                        const mostRecent = gridRoutes.sort((a, b) => new Date(b.start_date || 0) - new Date(a.start_date || 0))[0];
                        diverseRoutes.push(mostRecent);
                    }
                }
                
                console.log(`üìç GEOGRAPHIC DIVERSITY: Selected routes from ${routesByGrid.size} different areas`);
                return diverseRoutes.slice(0, maxCount);
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Geographic diversity fallback - using simple sampling:', error.message);
                // Fallback: simple random sampling
                return routes.slice(0, maxCount);
            }
        }

        // OPTION A: Create persistent markers that never get destroyed - only toggle visibility
        function createOrUpdatePersistentMarkers() {
            try {
                // ANIMATION PROTECTION: Never touch markers during animation
                if (isAnimationInProgress) {
                    console.log(`üé• ANIMATION PROTECTION: Skipping marker updates during animation`);
                    return;
                }
                
                const cameraHeight = viewer.camera.positionCartographic.height;
                console.log(`üîß PERSISTENT MARKERS: Camera height ${(cameraHeight / 1000).toFixed(0)}km`);
                
                // Skip if camera too close
                if (cameraHeight < 800000) {
                    console.log('üì∑ Camera too close - hiding all markers');
                    hideAllPersistentMarkers();
                    return;
                }
                
                // Determine zoom level for appropriate marker density
                const zoomLevel = cameraHeight > 10000000 ? 'global' : cameraHeight > 5000000 ? 'regional' : 'local';
                console.log(`üîç ZOOM LEVEL: ${zoomLevel}`);
                
                // Check if we need to create markers for this zoom level
                if (!ZOOM_LEVEL_MARKERS.has(zoomLevel)) {
                    console.log(`‚ú® CREATING: New marker set for ${zoomLevel} level`);
                    createMarkersForZoomLevel(zoomLevel);
                }
                
                // Show appropriate marker set and hide others
                showMarkerSetForZoomLevel(zoomLevel);
                
            } catch (error) {
                console.error('‚ùå Persistent marker error:', error);
            }
        }

        // Create markers for a specific zoom level (only called once per zoom level)
        function createMarkersForZoomLevel(zoomLevel) {
            console.log(`üèóÔ∏è BUILDING: Persistent markers for ${zoomLevel} zoom level`);
            
            // Apply filters to get relevant routes
            const filteredRoutes = sampleRoutes.filter(route => {
                const matchesTypeFilter = currentFilter === 'all' || route.type === currentFilter;
                const isZwiftActivity = isZwiftRoute(route);
                const shouldInclude = matchesTypeFilter && (!isZwiftActivity || showZwiftRoutes);
                return shouldInclude;
            });
            
            console.log(`üìä FILTERED: ${filteredRoutes.length} routes for ${zoomLevel} markers`);
            
            // Performance optimization for zoom level
            let routesToCluster = filteredRoutes;
            const maxRoutes = {
                'global': 50,    // Very few markers for global view
                'regional': 100, // Medium density for regional 
                'local': 200     // Higher density for local view
            };
            
            if (filteredRoutes.length > maxRoutes[zoomLevel]) {
                routesToCluster = filteredRoutes.slice(0, maxRoutes[zoomLevel]);
                console.log(`‚ö° OPTIMIZED: Using ${routesToCluster.length} routes for ${zoomLevel} performance`);
            }
            
            // Create clusters
            const clusters = clusterRoutes(routesToCluster, zoomLevel === 'global' ? 500 : zoomLevel === 'regional' ? 200 : 100);
            const markers = new Map();
            
            // Create persistent marker entities
            clusters.forEach((cluster, index) => {
                if (cluster.routes.length === 0) return;
                
                const markerId = `${zoomLevel}_${index}`;
                const zwiftRoutesInCluster = cluster.routes.filter(r => isZwiftRoute(r));
                const isZwiftCluster = zwiftRoutesInCluster.length > cluster.routes.length / 2; // Majority Zwift
                
                const markerEntity = viewer.entities.add({
                    id: markerId,
                    name: `${cluster.routes.length} routes in ${cluster.city}`,
                    position: Cesium.Cartesian3.fromDegrees(cluster.centerLng, cluster.centerLat, 500),
                    billboard: {
                        image: createClusterIcon(cluster.routes.length),
                        scale: 1.0,
                        verticalOrigin: Cesium.VerticalOrigin.CENTER,
                        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                        disableDepthTestDistance: 100000,
                        show: true, // Start visible
                        // üö® FIXED: Add proper scaling to persistent markers too
                        scaleByDistance: new Cesium.NearFarScalar(500, 2.0, 20000000, 0.6), // Bigger when close, visible when far
                        translucencyByDistance: new Cesium.NearFarScalar(1000, 1.0, 25000000, 0.8) // Stay visible much longer
                    }
                });
                
                // Store marker with metadata
                markers.set(markerId, {
                    entity: markerEntity,
                    routes: cluster.routes,
                    isZwift: isZwiftCluster,
                    city: cluster.city,
                    zoomLevel: zoomLevel
                });
                
                // Set up click handler
                markerEntity.cluster = cluster; // For compatibility with existing click handlers
            });
            
            // Store marker set
            ZOOM_LEVEL_MARKERS.set(zoomLevel, markers);
            console.log(`‚úÖ CREATED: ${markers.size} persistent markers for ${zoomLevel} level`);
        }
        
        // Show markers for specific zoom level, hide others
        function showMarkerSetForZoomLevel(targetZoomLevel) {
            if (currentMarkerSet === targetZoomLevel) {
                // Update visibility based on current filters
                updateMarkerVisibility(targetZoomLevel);
                return;
            }
            
            console.log(`üëÅÔ∏è SWITCHING: From ${currentMarkerSet} to ${targetZoomLevel} markers`);
            
            // Hide all marker sets
            ZOOM_LEVEL_MARKERS.forEach((markers, zoomLevel) => {
                markers.forEach(marker => {
                    marker.entity.show = false;
                });
            });
            
            // Show target marker set
            const targetMarkers = ZOOM_LEVEL_MARKERS.get(targetZoomLevel);
            if (targetMarkers) {
                updateMarkerVisibility(targetZoomLevel);
                currentMarkerSet = targetZoomLevel;
                console.log(`‚ú® VISIBLE: ${targetMarkers.size} markers for ${targetZoomLevel}`);
            }
        }
        
        // Update visibility of markers based on current filters (Zwift toggle, etc.)
        function updateMarkerVisibility(zoomLevel) {
            const markers = ZOOM_LEVEL_MARKERS.get(zoomLevel);
            if (!markers) return;
            
            let visibleCount = 0;
            let hiddenCount = 0;
            
            markers.forEach(marker => {
                // Apply current filters
                const shouldShow = shouldMarkerBeVisible(marker);
                marker.entity.show = shouldShow;
                
                if (shouldShow) visibleCount++;
                else hiddenCount++;
            });
            
            console.log(`üëÅÔ∏è VISIBILITY: ${visibleCount} shown, ${hiddenCount} hidden in ${zoomLevel} level`);
        }
        
        // üö® ENHANCED: Determine if marker should be visible with detailed debugging
        function shouldMarkerBeVisible(marker) {
            // Debug info for first few markers during Zwift toggles
            const debugThisMarker = Math.random() < 0.1; // 10% sampling for debug
            
            if (debugThisMarker) {
                console.log(`üîç MARKER DEBUG: isZwift=${marker.isZwift}, showZwiftRoutes=${showZwiftRoutes}, currentFilter=${currentFilter}`);
                console.log(`üîç MARKER ROUTES:`, marker.routes.map(r => ({ name: r.name, type: r.type, isZwift: isZwiftRoute(r) })));
            }
            
            // Apply Zwift filter
            if (marker.isZwift && !showZwiftRoutes) {
                if (debugThisMarker) console.log(`üîç HIDDEN: Zwift marker when showZwiftRoutes=false`);
                return false;
            }
            
            // üö® FIX: Apply type filter with undefined protection
            const safeCurrentFilter = currentFilter || 'all'; // Protect against undefined
            if (safeCurrentFilter !== 'all') {
                const matchingRoutes = marker.routes.filter(route => route.type === safeCurrentFilter);
                if (matchingRoutes.length === 0) {
                    if (debugThisMarker) console.log(`üîç HIDDEN: No routes match filter ${safeCurrentFilter}`);
                    return false;
                }
            }
            
            if (debugThisMarker) console.log(`üîç VISIBLE: Marker passes all filters`);
            return true;
        }
        
        // Hide all persistent markers (used when camera too close)
        function hideAllPersistentMarkers() {
            ZOOM_LEVEL_MARKERS.forEach(markers => {
                markers.forEach(marker => {
                    marker.entity.show = false;
                });
            });
            currentMarkerSet = null;
        }

        // LEGACY FUNCTION - Replace with persistent marker system
        function createClusterMarkers() {
            try {
                // ANIMATION PROTECTION: Never touch markers during animation to prevent disappearing
                if (isAnimationInProgress) {
                    console.log(`üé• ANIMATION PROTECTION: Skipping createClusterMarkers - animation in progress`);
                    return;
                }
                
                const now = Date.now();
                
                // THROTTLE: Prevent rapid successive calls that cause marker disappearance
                // CRITICAL: Check throttling BEFORE clearing existing markers!
                if (now - lastMarkerCreation < MARKER_THROTTLE_MS) {
                    console.log(`‚è±Ô∏è THROTTLED: createClusterMarkers skipped (last created ${now - lastMarkerCreation}ms ago)`);
                    return;
                }
                
                console.log(`üîß DEBUG: createClusterMarkers called - current markers: ${clusterMarkers.length}, routes: ${sampleRoutes.length}, animation in progress: ${isAnimationInProgress}`);
                
                // CRITICAL: Only update timestamp AFTER we're sure we'll complete the recreation
                lastMarkerCreation = now;
                
                // ROBUST: Clear existing cluster markers safely with better error handling
                clusterMarkers.forEach(marker => {
                    try {
                        if (marker && viewer.entities.contains(marker)) {
                            viewer.entities.remove(marker);
                        }
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Marker removal error (non-critical):', error.message);
                    }
                });
                clusterMarkers = [];
                
                console.log('üó∫Ô∏è Creating cluster markers safely...');
            
            // Get current camera height to determine clustering
            const cameraHeight = viewer.camera.positionCartographic.height;
            
            console.log(`üîç Creating cluster markers at height: ${(cameraHeight / 1000).toFixed(0)}km`);
            
            // ENHANCED: Be more generous with marker creation to prevent permanent loss
            if (cameraHeight < 800000) { // Reduced threshold from 1M to 800K
                console.log('üîç Camera too close for clusters - markers hidden but not destroyed');
                return;
            }
            
            // Safety check: ensure we have routes to cluster
            if (!sampleRoutes || sampleRoutes.length === 0) {
                console.warn('‚ö†Ô∏è No routes available for clustering');
                return;
            }
            
            // PERFORMANCE OPTIMIZATION: Smart filtering for large datasets
            const filteredRoutes = sampleRoutes.filter(route => {
                const matchesTypeFilter = currentFilter === 'all' || route.type === currentFilter;
                const isZwiftActivity = isZwiftRoute(route);
                const shouldInclude = matchesTypeFilter && (!isZwiftActivity || showZwiftRoutes);
                return shouldInclude;
            });
            
            // CRITICAL PERFORMANCE: If too many routes, intelligently subsample for clustering
            const MAX_ROUTES_FOR_CLUSTERING = 200; // Prevent system overload
            let routesForClustering = filteredRoutes;
            
            if (filteredRoutes.length > MAX_ROUTES_FOR_CLUSTERING) {
                console.log(`üî• PERFORMANCE: ${filteredRoutes.length} routes detected - subsampling to ${MAX_ROUTES_FOR_CLUSTERING} for clustering`);
                
                // Smart subsampling: prioritize recent routes and geographic diversity
                const sortedByDate = [...filteredRoutes].sort((a, b) => new Date(b.start_date || 0) - new Date(a.start_date || 0));
                const recentRoutes = sortedByDate.slice(0, Math.floor(MAX_ROUTES_FOR_CLUSTERING * 0.7)); // 70% recent
                const geographicallyDiverseRoutes = getGeographicallyDiverseRoutes(sortedByDate.slice(Math.floor(MAX_ROUTES_FOR_CLUSTERING * 0.7)), Math.floor(MAX_ROUTES_FOR_CLUSTERING * 0.3));
                
                routesForClustering = [...recentRoutes, ...geographicallyDiverseRoutes];
                console.log(`üéØ SMART SAMPLING: ${recentRoutes.length} recent + ${geographicallyDiverseRoutes.length} diverse = ${routesForClustering.length} total`);
            }
            
            // DEBUG: Check what's happening with the filters
            const typeFilteredRoutes = sampleRoutes.filter(r => currentFilter === 'all' || r.type === currentFilter);
            console.log(`üîß DEBUG: Cluster filtering - currentFilter: "${currentFilter}"`);
            console.log(`üîß DEBUG: Sample route types:`, sampleRoutes.slice(0, 5).map(r => r.type));
            console.log(`üîß DEBUG: Total routes: ${sampleRoutes.length}, After type filter: ${typeFilteredRoutes.length}, After Zwift filter: ${filteredRoutes.length}, For clustering: ${routesForClustering.length}, showZwiftRoutes: ${showZwiftRoutes}`);
            
            const clusters = clusterRoutes(routesForClustering, 100); // 100km clustering radius with performance optimization
            
            clusters.forEach(cluster => {
                if (cluster.routes.length === 0) return;
                
                const clusterMarker = viewer.entities.add({
                    name: `${cluster.routes.length} routes in ${cluster.city}`,
                    position: Cesium.Cartesian3.fromDegrees(cluster.centerLng, cluster.centerLat, 500), // Lower height for better grounding
                    billboard: {
                        image: createClusterIcon(cluster.routes.length),
                        scale: 1.0, // Full size for better visibility
                        verticalOrigin: Cesium.VerticalOrigin.CENTER, // Center for better balance
                        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                        disableDepthTestDistance: 100000, // Always visible when close
                        // üö® FIXED: Better marker scaling - smaller far scale, larger close scale
                        scaleByDistance: new Cesium.NearFarScalar(500, 2.0, 20000000, 0.6), // Bigger when close, larger when far
                        translucencyByDistance: new Cesium.NearFarScalar(1000, 1.0, 25000000, 0.8) // Stay visible much longer
                    }
                });
                
                // Store cluster data for click handling
                clusterMarker.cluster = cluster;
                clusterMarkers.push(clusterMarker);
            });
            
            console.log(`‚úÖ Successfully created ${clusterMarkers.length} cluster markers`);
            
            // RECOVERY: Set up periodic marker health check
            if (!window.markerHealthCheck) {
                window.markerHealthCheck = setInterval(() => {
                    if (!isAnimationInProgress) { // Don't interfere with animations
                        const currentHeight = viewer.camera.positionCartographic.height;
                        
                        // Check if we have any routes that should be visible (after Zwift filtering)
                        const visibleRoutes = sampleRoutes.filter(route => {
                            const matchesTypeFilter = currentFilter === 'all' || route.type === currentFilter;
                            const isZwiftActivity = isZwiftRoute(route);
                            const shouldInclude = matchesTypeFilter && (!isZwiftActivity || showZwiftRoutes);
                            return shouldInclude;
                        });
                        
                        // üö® FIXED: Lower altitude threshold so markers stay visible when zooming in
                        if (currentHeight > 50000 && clusterMarkers.length === 0 && visibleRoutes.length > 0) {
                            console.log('üöë MARKER RECOVERY: No markers found when they should exist - recreating...');
                            createClusterMarkers();
                        }
                    }
                }, 5000); // Check every 5 seconds
            }
            
            } catch (error) {
                console.error('‚ùå createClusterMarkers failed:', error);
                // Continue without crashing the app
            }
        }
        
        function createClusterIcon(count) {
            // Create a high-DPI canvas for crisp rendering with expandable size for large counts
            const canvas = document.createElement('canvas');
            // ENHANCED: Better scaling for large numbers (up to 1000+)
            let size;
            if (count >= 1000) {
                size = 120; // Large for 1000+
            } else if (count >= 500) {
                size = 100; // Medium-large for 500+
            } else if (count >= 100) {
                size = 85;  // Medium for 100+
            } else {
                size = Math.max(50, Math.min(count * 2 + 45, 75)); // Dynamic sizing for smaller counts
            }
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Enable high-DPI rendering
            const dpr = window.devicePixelRatio || 1;
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            ctx.scale(dpr, dpr);
            
            const centerX = size / 2;
            const centerY = size / 2;
            const radius = size / 2 - 4;
            
            // Professional color scheme based on count
            let bgColor, borderColor, textColor;
            if (count > 20) {
                bgColor = '#dc2626';      // Red for high density
                borderColor = '#fecaca';
                textColor = '#ffffff';
            } else if (count > 10) {
                bgColor = '#ea580c';      // Orange for medium density  
                borderColor = '#fed7aa';
                textColor = '#ffffff';
            } else if (count > 5) {
                bgColor = '#2563eb';      // Blue for moderate density
                borderColor = '#bfdbfe';
                textColor = '#ffffff';
            } else {
                bgColor = '#059669';      // Green for low density
                borderColor = '#a7f3d0';
                textColor = '#ffffff';
            }
            
            // Draw shadow (modern depth effect)
            ctx.beginPath();
            ctx.arc(centerX + 1, centerY + 2, radius, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fill();
            
            // Draw main circle with gradient
            const gradient = ctx.createRadialGradient(centerX - radius/3, centerY - radius/3, 0, centerX, centerY, radius);
            gradient.addColorStop(0, bgColor);
            gradient.addColorStop(1, bgColor + 'dd'); // Slightly darker edge
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Draw elegant border
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2.5;
            ctx.stroke();
            
            // Add inner highlight ring
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 3, 0, 2 * Math.PI);
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Draw number with professional typography - enhanced for large numbers
            ctx.fillStyle = textColor;
            let fontSize;
            if (count >= 1000) {
                fontSize = Math.min(size * 0.25, 18); // Smaller font for big numbers
            } else if (count >= 100) {
                fontSize = Math.min(size * 0.3, 20);
            } else {
                fontSize = Math.max(12, Math.min(size * 0.35, 24));
            }
            ctx.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Add subtle text shadow for better readability
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 1;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 1;
            
            // Format large numbers for better readability
            let displayText = count.toString();
            if (count >= 1000) {
                displayText = (count / 1000).toFixed(1) + 'K'; // Show as "1.2K" for thousands
            }
            ctx.fillText(displayText, centerX, centerY);
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            return canvas;
        }
        
        // Initialize routes - try Strava first, fallback to samples
        async function initializeRoutes() {
            console.log('üîÑ Initializing routes...');
            
            try {
                sampleRoutes = await loadStravaRoutes();
                console.log(`‚úÖ Routes initialized: ${sampleRoutes.length} routes loaded`);
                // üöÄ CRITICAL FIXES #5 & #6: Invalidate caches when new routes loaded
                invalidateStatsCache();
                invalidateFilteredRoutesCache();
            } catch (error) {
                console.error('‚ùå Failed to initialize routes:', error);
                sampleRoutes = generateSampleRoutes();
                console.log('üîÑ Using sample routes as fallback');
                // üöÄ CRITICAL FIXES #5 & #6: Invalidate caches for fallback routes too
                invalidateStatsCache();
                invalidateFilteredRoutesCache();
            }
            
            populateRoutesList();
            
            // Create initial cluster markers and display all routes
            setTimeout(() => {
                // NEW ARCHITECTURE: Use persistent markers instead of recreating
                createOrUpdatePersistentMarkers();
                setupCameraListeners();
                
                // Start with persistent markers - no automatic route display
                // Routes can be viewed by clicking cluster markers or using animation
                console.log('‚úÖ PERSISTENT MARKER SYSTEM: Initialized successfully');
            }, 1000);
        }
        
        // Setup camera change listeners for clustering and click handlers
        function setupCameraListeners() {
            let lastUpdateHeight = 0;
            
            viewer.camera.changed.addEventListener(() => {
                const currentHeight = viewer.camera.positionCartographic.height;
                
                // Only update markers if height changed significantly AND not during animation
                if (Math.abs(currentHeight - lastUpdateHeight) > currentHeight * 0.1 && !isAnimationInProgress) {
                    lastUpdateHeight = currentHeight;
                    
                    // Throttle cluster updates more aggressively to prevent marker disappearance
                    clearTimeout(window.clusterUpdateTimeout);
                    window.clusterUpdateTimeout = setTimeout(() => {
                        // Double-check: Only recreate markers if we're not in a rapid interaction phase
                        // NEW ARCHITECTURE: Update persistent markers instead of recreating
                        console.log('üì∑ CAMERA CHANGE: Updating persistent markers');
                        createOrUpdatePersistentMarkers();
                    }, 1200); // Increased delay to reduce conflicts with button interactions
                }
            });
            
            // FIXED: Universal Earth-centered zoom-out behavior
            viewer.camera.moveEnd.addEventListener(() => {
                // CRITICAL: Don't interfere with animations!
                if (isAnimationInProgress) {
                    console.log('üé• Animation in progress - skipping camera corrections');
                    return;
                }
                
                const currentPitch = viewer.camera.pitch;
                const currentHeight = viewer.camera.positionCartographic.height;
                const currentPosition = viewer.camera.positionCartographic;
                
                // CRITICAL: Determine if we're in "close marker view" mode
                const isCloseMarkerView = currentHeight < 1000000 && currentPitch > -Math.PI/3; // Less than 1M meters AND not looking straight down
                
                if (isCloseMarkerView) {
                    // Allow angled views for close marker inspection
                    console.log('üîç Close marker view: Allowing angled camera');
                    return;
                }
                
                // For ALL other cases: enforce Earth-centered perpendicular view
                let needsCorrection = false;
                let targetPitch = currentPitch;
                
                if (currentHeight > 3000000) {
                    // High altitude: ALWAYS perpendicular to Earth (90¬∞ straight down)
                    targetPitch = -Math.PI / 2;
                    needsCorrection = Math.abs(targetPitch - currentPitch) > 0.1; // 6 degree tolerance
                    if (needsCorrection) {
                        console.log('üéØ High altitude: Enforcing perpendicular Earth view');
                    }
                } else if (currentHeight > 1000000) {
                    // Medium altitude: Ensure steep downward angle (at least 70¬∞ down)
                    targetPitch = Math.min(currentPitch, -Math.PI * 0.39); // At least 70¬∞ down
                    needsCorrection = currentPitch > -Math.PI * 0.39;
                    if (needsCorrection) {
                        console.log('üéØ Medium altitude: Enforcing steep Earth view');
                    }
                }
                
                // Apply correction with smooth transition
                if (needsCorrection) {
                    viewer.camera.flyTo({
                        destination: Cesium.Cartesian3.fromRadians(
                            currentPosition.longitude,
                            currentPosition.latitude,
                            currentHeight
                        ),
                        orientation: {
                            heading: 0.0, // Always face north for consistency
                            pitch: targetPitch,
                            roll: 0.0
                        },
                        duration: 0.8,
                        convert: false
                    });
                }
            });
            
            // Add click handler for cluster markers
            const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
            handler.setInputAction((event) => {
                const pickedFeature = viewer.scene.pick(event.position);
                
                if (pickedFeature && pickedFeature.id && pickedFeature.id.cluster) {
                    const cluster = pickedFeature.id.cluster;
                    console.log(`üéØ Clicked cluster with ${cluster.routes.length} routes`);
                    
                    // Calculate bounding box for all routes in the cluster
                    const allPositions = [];
                    cluster.routes.forEach(route => {
                        if (route.coordinates && route.coordinates.length > 0) {
                            route.coordinates.forEach(coord => {
                                if (coord.length >= 2) {
                                    allPositions.push(Cesium.Cartesian3.fromDegrees(coord[0], coord[1]));
                                }
                            });
                        }
                    });
                    
                    if (allPositions.length > 0) {
                        // Create bounding sphere for all routes in cluster
                        const boundingSphere = Cesium.BoundingSphere.fromPoints(allPositions);
                        const distance = Math.max(boundingSphere.radius * 3, 10000); // More conservative distance
                        
                        // Fly to show all routes in the cluster with proper downward angle
                        viewer.camera.flyToBoundingSphere(boundingSphere, {
                            duration: 2.0,
                            offset: new Cesium.HeadingPitchRange(0, -Math.PI/3, distance), // 60¬∞ looking down angle
                            complete: () => {
                                // Smooth adjustment to maintain good viewing angle
                                const currentPitch = viewer.camera.pitch;
                                const targetPitch = Math.max(currentPitch, -Math.PI/2.5); // At least 72¬∞ down
                                
                                if (Math.abs(targetPitch - currentPitch) > 0.02) {
                                    viewer.camera.flyTo({
                                        destination: viewer.camera.position,
                                        orientation: {
                                            heading: viewer.camera.heading,
                                            pitch: targetPitch,
                                            roll: 0.0
                                        },
                                        duration: 0.8,
                                        convert: false
                                    });
                                }
                                
                                viewer.scene.requestRender();
                                console.log(`‚úÖ Flew to cluster region with ${cluster.routes.length} routes`);
                                
                                // Show routes in this cluster temporarily  
                                showClusterRoutes(cluster);
                                
                                // FIXED: More aggressive marker recreation system
                                setTimeout(() => {
                                    try {
                                        console.log('üîÑ Recreating cluster markers after route display...');
                                        createClusterMarkers();
                                    } catch (error) {
                                        console.warn('‚ö†Ô∏è Marker recreation error (non-critical):', error.message);
                                    }
                                }, 800); // Slightly faster recreation
                            }
                        });
                    }
                }
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
        }
        
        // Generate highly variable random colors for route differentiation
        function generateRouteColors(routeCount) {
            const colors = [];
            const usedHues = new Set(); // Prevent similar colors
            
            // Create a diverse color palette with random distribution
            for (let i = 0; i < routeCount; i++) {
                let hue, attempts = 0;
                
                // Find a unique hue that's not too close to existing ones
                do {
                    hue = Math.random() * 360; // FULLY RANDOM hue across spectrum
                    attempts++;
                } while (attempts < 50 && Array.from(usedHues).some(usedHue => Math.abs(hue - usedHue) < 15));
                
                usedHues.add(hue);
                
                // High variability in saturation and lightness
                const saturation = 60 + Math.random() * 40; // 60-100% (very vibrant)
                const lightness = 35 + Math.random() * 30;  // 35-65% (good visibility range)
                
                // Convert HSL to RGB
                const rgb = hslToRgb(hue / 360, saturation / 100, lightness / 100);
                colors.push(Cesium.Color.fromBytes(rgb.r, rgb.g, rgb.b, 200)); // Slight transparency for layering
            }
            
            console.log(`üåà Generated ${colors.length} highly variable random colors`);
            return colors;
        }
        
        // HSL to RGB conversion for color generation
        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }
        
        // Hurricane-style route differentiation - each route gets unique color
        function showClusterRoutesWithDifferentiation(cluster) {
            // Clear any existing auto-cleanup timeout
            if (window.routeDisplayTimeout) {
                clearTimeout(window.routeDisplayTimeout);
                console.log('üóüÔ∏è Cleared previous route cleanup timeout');
            }
            
            // CRITICAL: Clear any existing temporary route displays before showing new ones
            console.log('üóëÔ∏è Clearing previous routes before showing new cluster...');
            clearTemporaryRoutes();
            
            console.log(`üåÄ HURRICANE-STYLE: Showing ${cluster.routes.length} routes with unique colors`);
            
            // Generate unique colors for each route
            const routeColors = generateRouteColors(cluster.routes.length);
            
            cluster.routes.forEach((route, index) => {
                if (route.coordinates && route.coordinates.length > 0) {
                    const positions = route.coordinates.map(coord => 
                        Cesium.Cartesian3.fromDegrees(coord[0], coord[1])
                    );
                    
                    // Each route gets its own unique color
                    const uniqueColor = routeColors[index];
                    
                    // Create route entity with persistent properties to prevent color changes
                    const routeEntity = viewer.entities.add({
                        polyline: {
                            positions: positions,
                            width: 8, // Even thicker for better color visibility
                            material: uniqueColor, // FIXED: Use direct color instead of glow to prevent white line
                            clampToGround: true,
                            outline: false, // CRITICAL: Disable outline that causes white line
                            extrudedHeight: 0 // Ensure no extrusion
                        },
                        name: `Route-${index + 1}: ${route.name}`,
                        description: `${route.type} - ${route.distance}km - Color #${index + 1}`
                    });
                    
                    // CRITICAL: Store color to prevent changes
                    routeEntity._originalColor = uniqueColor;
                    routeEntity._colorLocked = true;
                    
                    // Mark as temporary for cleanup
                    routeEntity.isTemporary = true;
                    routeEntity.routeIndex = index;
                    routeEntity.route = route;
                    
                    console.log(`üåà Route ${index + 1}/${cluster.routes.length}: "${route.name}" - ${route.type}`);
                }
            });
            
            // Hurricane popup removed - routes display directly without popup
            
            console.log('‚ú® Routes will persist until you click a different marker (no auto-timeout)');
            
            // REMOVED: No automatic cleanup timeout - routes persist until user action!
            // Routes will only be cleared when:
            // 1. User clicks a different cluster marker (clearTemporaryRoutes called at start of this function)
            // 2. User manually clears them via button
            // 3. User refreshes page
            
            viewer.scene.requestRender();
        }
        
        // Hurricane popup completely removed per user request - routes show directly without popup window
        
        // Legacy function for compatibility (now calls the enhanced version)
        function showClusterRoutes(cluster) {
            showClusterRoutesWithDifferentiation(cluster);
        }
        
        // ROBUST: Clear temporary route displays with better error handling
        function clearTemporaryRoutes() {
            try {
                console.log('üßπ Cleaning up temporary routes...');
                const entitiesToRemove = [];
                
                // Safely collect temporary entities
                viewer.entities.values.forEach(entity => {
                    try {
                        if (entity && entity.isTemporary) {
                            entitiesToRemove.push(entity);
                        }
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Entity check error (non-critical):', error.message);
                    }
                });
                
                console.log(`üßπ Removing ${entitiesToRemove.length} temporary routes...`);
                
                // Safely remove entities
                entitiesToRemove.forEach(entity => {
                    try {
                        if (viewer.entities.contains(entity)) {
                            viewer.entities.remove(entity);
                        }
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Entity removal error (non-critical):', error.message);
                    }
                });
                
                viewer.scene.requestRender();
                console.log('‚úÖ Temporary routes cleaned up successfully');
            } catch (error) {
                console.error('‚ùå clearTemporaryRoutes failed:', error);
            }
        }
        
        // üöÄ CRITICAL FIX #4: GPU-optimized batch rendering for 1000+ routes
        function displayAllRoutes() {
            console.log(`üöÄ GPU BATCHING: Displaying ${sampleRoutes.length} routes with optimized rendering`);
            
            if (!viewer || !viewer.entities) {
                console.error('‚ùå Viewer or entities not available for route display');
                return;
            }
            
            // Clear existing permanent routes
            clearAllPermanentRoutes();
            
            // üéØ PERFORMANCE: Group routes by type for batch rendering
            const cyclingRoutes = [];
            const runningRoutes = [];
            let validRoutes = 0;
            let skippedRoutes = 0;
            
            sampleRoutes.forEach((route, index) => {
                if (route.coordinates && route.coordinates.length > 1) {
                    const positions = route.coordinates.map(coord => {
                        if (!coord || coord.length < 2) return null;
                        return Cesium.Cartesian3.fromDegrees(coord[0], coord[1], 10);
                    }).filter(pos => pos !== null);
                    
                    if (positions.length >= 2) {
                        const routeData = { ...route, positions };
                        if (route.type === 'cycling') {
                            cyclingRoutes.push(routeData);
                        } else {
                            runningRoutes.push(routeData);
                        }
                        validRoutes++;
                    } else {
                        skippedRoutes++;
                    }
                } else {
                    skippedRoutes++;
                }
            });
            
            console.log(`üéØ BATCHING: ${validRoutes} valid routes (${cyclingRoutes.length} cycling, ${runningRoutes.length} running), ${skippedRoutes} skipped`);
            
            // üöÄ BATCH RENDER: Create fewer GPU entities by combining routes
            if (cyclingRoutes.length > 0) {
                createBatchedRouteEntities(cyclingRoutes, 'cycling', Cesium.Color.BLUE.withAlpha(0.8));
            }
            
            if (runningRoutes.length > 0) {
                createBatchedRouteEntities(runningRoutes, 'running', Cesium.Color.RED.withAlpha(0.8));
            }
            
            console.log(`üìä GPU BATCHING SUMMARY:`);
            console.log(`üìä - Total routes processed: ${sampleRoutes.length}`);
            console.log(`üìä - Valid routes: ${validRoutes}, Skipped: ${skippedRoutes}`);
            console.log(`üìä - GPU entities created: ${permanentRouteEntities.length} (vs ${validRoutes} individual entities saved)`);
            console.log(`üìä - Memory efficiency: ${validRoutes > 0 ? ((validRoutes - permanentRouteEntities.length) / validRoutes * 100).toFixed(1) : 0}% fewer GPU objects`);
            
            showAllRoutes = true;
            updatePermanentRouteVisibility();
            viewer.scene.requestRender();
            
            console.log(`üöÄ GPU BATCHING: Created ${permanentRouteEntities.length} efficient entities for ${validRoutes} routes`);
        }

        // üöÄ CRITICAL FIX #4: Batch route entities for GPU efficiency
        function createBatchedRouteEntities(routes, routeType, color) {
            const batchSize = 50; // Routes per GPU entity (optimal balance)
            const batches = [];
            
            // Group routes into batches for optimal GPU performance
            for (let i = 0; i < routes.length; i += batchSize) {
                batches.push(routes.slice(i, i + batchSize));
            }
            
            console.log(`üéØ ${routeType.toUpperCase()}: Creating ${batches.length} GPU entities for ${routes.length} routes`);
            
            batches.forEach((batch, batchIndex) => {
                // Combine all routes in this batch into single polyline collection
                const allPositions = [];
                const routeMetadata = [];
                
                batch.forEach(route => {
                    if (route.positions && route.positions.length >= 2) {
                        // Add separator between routes (small gap for visual distinction)
                        if (allPositions.length > 0) {
                            allPositions.push(undefined); // Cesium polyline break
                        }
                        allPositions.push(...route.positions);
                        
                        // Store metadata for individual route access (when clicking markers)
                        routeMetadata.push({
                            name: route.name,
                            id: route.id,
                            startIndex: allPositions.length - route.positions.length,
                            endIndex: allPositions.length - 1,
                            originalRoute: route
                        });
                    }
                });
                
                if (allPositions.length > 0) {
                    // Create single GPU entity for entire batch
                    const batchEntity = viewer.entities.add({
                        polyline: {
                            positions: allPositions,
                            width: 4,
                            material: color,
                            clampToGround: true,
                            show: true,
                            outline: true,
                            outlineColor: Cesium.Color.WHITE.withAlpha(0.3)
                        },
                        name: `BatchedRoutes-${routeType}-${batchIndex}`,
                        description: `${batch.length} ${routeType} routes`,
                        // Store metadata for individual route extraction
                        routeMetadata: routeMetadata,
                        routeType: routeType,
                        isBatched: true
                    });
                    
                    // Mark as permanent and track
                    batchEntity.isPermanent = true;
                    permanentRouteEntities.push(batchEntity);
                    
                    console.log(`‚úÖ Batch ${batchIndex + 1}/${batches.length}: ${batch.length} routes ‚Üí 1 GPU entity`);
                }
            });
        }
        
        // Clear all permanent routes
        function clearAllPermanentRoutes() {
            permanentRouteEntities.forEach(entity => {
                viewer.entities.remove(entity);
            });
            permanentRouteEntities = [];
            showAllRoutes = false;
            viewer.scene.requestRender();
        }
        
        // Update visibility of permanent routes based on current filter and Zwift toggle
        function updatePermanentRouteVisibility() {
            if (!showAllRoutes) return;
            
            console.log(`üîÑ Updating permanent route visibility - showZwiftRoutes: ${showZwiftRoutes}`);
            let hiddenCount = 0;
            let shownCount = 0;
            let zwiftHiddenCount = 0;
            
            permanentRouteEntities.forEach(entity => {
                if (entity.route) {
                    const matchesFilter = currentFilter === 'all' || entity.route.type === currentFilter;
                    const isZwiftActivity = isZwiftRoute(entity.route);
                    const shouldShow = matchesFilter && (!isZwiftActivity || showZwiftRoutes);
                    
                    entity.polyline.show = shouldShow;
                    
                    if (shouldShow) {
                        shownCount++;
                    } else {
                        hiddenCount++;
                        if (isZwiftActivity) zwiftHiddenCount++;
                    }
                    
                    // Debug a few examples
                    if (isZwiftActivity && hiddenCount < 5) {
                        console.log(`‚öôÔ∏è Zwift route "${entity.route.name}" - shouldShow: ${shouldShow}`);
                    }
                }
            });
            
            console.log(`üó∫Ô∏è Routes shown: ${shownCount}, hidden: ${hiddenCount} (${zwiftHiddenCount} Zwift routes hidden)`);
            viewer.scene.requestRender();
        }
        
        // Toggle all routes display
        function toggleAllRoutesDisplay() {
            if (showAllRoutes) {
                clearAllPermanentRoutes();
                console.log('üåç Routes hidden');
            } else {
                displayAllRoutes();
                console.log('üåç Routes displayed');
            }
        }

        // üöÄ CRITICAL FIX #3: Virtual scrolling for route list performance
        let virtualScrollState = {
            filteredRoutes: [],
            itemHeight: 80, // Estimated height of each route item in pixels
            visibleItems: 15, // Number of items to render at once
            scrollTop: 0,
            startIndex: 0,
            endIndex: 15,
            totalHeight: 0
        };

        // üöÄ CRITICAL FIX #6: Pre-filtered route collections for instant filter changes
        let filteredRoutesCache = {
            all: [],
            cycling: [], 
            running: [],
            allWithZwift: [],
            cyclingWithZwift: [],
            runningWithZwift: [],
            isValid: false,
            lastUpdate: 0
        };

        // Populate the routes list with virtual scrolling and cached filtering
        function populateRoutesList() {
            const routesList = document.getElementById('routesList');
            const startTime = performance.now();
            
            console.log(`üìú Populating routes list with cached filtering - showZwiftRoutes: ${showZwiftRoutes}`);
            
            // Check if filtered cache needs rebuilding
            if (!filteredRoutesCache.isValid) {
                rebuildFilteredRoutesCache();
            }
            
            // üö® FIX: Get pre-filtered routes with undefined protection  
            const safeCurrentFilter = currentFilter || 'all'; // Protect against undefined
            const cacheKey = showZwiftRoutes 
                ? `${safeCurrentFilter}WithZwift`  
                : safeCurrentFilter;
            
            const filteredRoutes = filteredRoutesCache[cacheKey] || [];
            
            const filterTime = performance.now() - startTime;
            console.log(`üöÄ FILTER CACHE: Instant lookup in ${filterTime.toFixed(2)}ms - ${filteredRoutes.length} routes (key: ${cacheKey})`);
            
            // Update virtual scroll state
            virtualScrollState.filteredRoutes = filteredRoutes;
            virtualScrollState.totalHeight = filteredRoutes.length * virtualScrollState.itemHeight;
            
            // Set up virtual scrolling container
            setupVirtualScrollContainer(routesList);
            
            // Render initial visible items
            renderVisibleRoutes();
        }

        function rebuildFilteredRoutesCache() {
            if (sampleRoutes.length === 0) {
                filteredRoutesCache.isValid = false;
                return;
            }
            
            const startTime = performance.now();
            console.log(`üîÑ REBUILDING FILTER CACHE: Processing ${sampleRoutes.length} routes...`);
            
            // Pre-calculate all possible filter combinations
            const allRoutes = sampleRoutes;
            const cyclingRoutes = sampleRoutes.filter(route => route.type === 'cycling');
            const runningRoutes = sampleRoutes.filter(route => route.type === 'running');
            
            // Filter out Zwift routes for non-Zwift collections
            const allNonZwift = allRoutes.filter(route => !isZwiftRoute(route));
            const cyclingNonZwift = cyclingRoutes.filter(route => !isZwiftRoute(route));
            const runningNonZwift = runningRoutes.filter(route => !isZwiftRoute(route));
            
            // Cache all filter combinations
            filteredRoutesCache.all = allNonZwift;
            filteredRoutesCache.cycling = cyclingNonZwift;
            filteredRoutesCache.running = runningNonZwift;
            filteredRoutesCache.allWithZwift = allRoutes;
            filteredRoutesCache.cyclingWithZwift = cyclingRoutes;
            filteredRoutesCache.runningWithZwift = runningRoutes;
            
            filteredRoutesCache.lastUpdate = Date.now();
            filteredRoutesCache.isValid = true;
            
            const buildTime = performance.now() - startTime;
            console.log(`‚úÖ FILTER CACHE BUILT: ${buildTime.toFixed(2)}ms for ${sampleRoutes.length} routes`);
            console.log(`üìä Filter cache: All(${allNonZwift.length}/${allRoutes.length}), Cycling(${cyclingNonZwift.length}/${cyclingRoutes.length}), Running(${runningNonZwift.length}/${runningRoutes.length})`);
        }

        function invalidateFilteredRoutesCache() {
            filteredRoutesCache.isValid = false;
            console.log('üóëÔ∏è Filter cache invalidated - will rebuild on next access');
        }

        // üöÄ CRITICAL FIX #8: Event delegation and memory leak prevention
        let routeClickHandler = null;
        let scrollHandler = null;
        const routeWeakMap = new WeakMap(); // Auto-cleanup when elements removed

        function setupVirtualScrollContainer(routesList) {
            // Clear existing content and remove old event listeners
            cleanupEventListeners(routesList);
            routesList.innerHTML = '';
            
            // Create virtual scroll structure
            routesList.innerHTML = `
                <div class="virtual-scroll-container" style="height: ${virtualScrollState.totalHeight}px; position: relative;">
                    <div class="virtual-scroll-content" style="position: absolute; top: 0; width: 100%;"></div>
                </div>
            `;
            
            // üéØ EVENT DELEGATION: Single click handler for all route items (prevents 1000+ individual listeners)
            routeClickHandler = (event) => {
                const routeItem = event.target.closest('.route-item');
                if (routeItem && routeItem.dataset.routeId) {
                    // Get route data from WeakMap or filtered cache
                    const routeData = routeWeakMap.get(routeItem) || 
                        virtualScrollState.filteredRoutes.find(r => r.id === routeItem.dataset.routeId);
                    
                    if (routeData) {
                        flyToRoute(routeData);
                    } else {
                        console.warn('‚ö†Ô∏è Route data not found for ID:', routeItem.dataset.routeId);
                    }
                }
            };
            
            // Add single delegated event listener to parent container
            routesList.addEventListener('click', routeClickHandler);
            
            // Add scroll event listener with throttling and cleanup reference
            let scrollTimeout;
            scrollHandler = () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    virtualScrollState.scrollTop = routesList.scrollTop;
                    updateVisibleIndices();
                    renderVisibleRoutes();
                }, 16); // ~60fps throttling
            };
            routesList.addEventListener('scroll', scrollHandler);
            
            console.log('üöÄ EVENT OPTIMIZATION: Using event delegation instead of individual listeners');
        }

        function cleanupEventListeners(routesList) {
            // Remove existing event listeners to prevent memory leaks
            if (routeClickHandler) {
                routesList.removeEventListener('click', routeClickHandler);
            }
            if (scrollHandler) {
                routesList.removeEventListener('scroll', scrollHandler);
            }
            
            // Clear WeakMap references (automatic cleanup)
            console.log('üßπ EVENT CLEANUP: Removed old event listeners and references');
        }

        function updateVisibleIndices() {
            const { scrollTop, itemHeight, visibleItems, filteredRoutes } = virtualScrollState;
            
            virtualScrollState.startIndex = Math.floor(scrollTop / itemHeight);
            virtualScrollState.endIndex = Math.min(
                virtualScrollState.startIndex + visibleItems + 5, // Render 5 extra for smooth scrolling
                filteredRoutes.length
            );
            
            // Ensure we don't go below 0
            virtualScrollState.startIndex = Math.max(0, virtualScrollState.startIndex);
        }

        function renderVisibleRoutes() {
            const { filteredRoutes, startIndex, endIndex, itemHeight } = virtualScrollState;
            const container = document.querySelector('.virtual-scroll-content');
            
            if (!container) return;
            
            // Clear existing items
            container.innerHTML = '';
            
            // Create only visible items
            for (let i = startIndex; i < endIndex; i++) {
                const route = filteredRoutes[i];
                if (!route) continue;
                
                const routeItem = document.createElement('div');
                routeItem.className = 'route-item';
                routeItem.dataset.routeId = route.id;
                routeItem.style.cssText = `
                    position: absolute;
                    top: ${i * itemHeight}px;
                    width: 100%;
                    height: ${itemHeight}px;
                    box-sizing: border-box;
                `;
                
                routeItem.innerHTML = `
                    <div class="route-name">
                        <div class="activity-icon ${route.type}"></div>
                        ${route.name}
                    </div>
                    <div class="route-details">
                        üìç ${route.location}<br>
                        üìè <span class="route-distance">${route.distance} km</span> ‚Ä¢ ‚è±Ô∏è ${Math.floor(route.time/60)}h ${route.time%60}m
                    </div>
                `;
                
                // üöÄ CRITICAL FIX #8: Store route data in WeakMap instead of individual event listeners
                routeWeakMap.set(routeItem, route);
                container.appendChild(routeItem);
            }
            
            // Performance monitoring
            if (filteredRoutes.length > 100) {
                console.log(`üöÄ Virtual scroll: Rendered ${endIndex - startIndex} of ${filteredRoutes.length} routes (${((endIndex - startIndex) / filteredRoutes.length * 100).toFixed(1)}% DOM usage)`);
            }
        }

        // Fly to a specific route
        function flyToRoute(route) {
            // Remove active class from all route items
            document.querySelectorAll('.route-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Add active class to clicked route
            document.querySelector(`[data-route-id="${route.id}"]`).classList.add('active');
            
            // üöÄ PERFORMANCE: Optimized entity cleanup to prevent memory leaks
            if (routeEntities.length > 0) {
                console.log(`üßπ Cleaning up ${routeEntities.length} route entities`);
                routeEntities.forEach(entity => {
                    if (entity && !entity.isDestroyed()) {
                        viewer.entities.remove(entity);
                    }
                });
                routeEntities = [];
                // Force garbage collection hint
                if (routeEntities.length > 100) {
                    viewer.scene.requestRender(); // Explicit render request after cleanup
                }
            }
            
            // Create route polyline with enhanced styling
            if (route.coordinates && route.coordinates.length > 0) {
                const positions = route.coordinates.map(coord => 
                    Cesium.Cartesian3.fromDegrees(coord[0], coord[1], 2) // Slight elevation for visibility
                );
                
                // Create main route line
                const routeColor = route.type === 'cycling' ? 
                    Cesium.Color.fromCssColorString('#3b82f6') : // Blue for cycling
                    Cesium.Color.fromCssColorString('#ef4444');  // Red for running
                
                const routeEntity = viewer.entities.add({
                    name: route.name,
                    polyline: {
                        positions: positions,
                        width: 6,
                        material: routeColor.withAlpha(0.9),
                        clampToGround: true,
                        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                        extrudedHeight: 0,
                        classificationType: Cesium.ClassificationType.TERRAIN
                    }
                });
                
                // Add start point marker
                if (positions.length > 0) {
                    const startPoint = viewer.entities.add({
                        name: `${route.name} - Start`,
                        position: positions[0],
                        point: {
                            pixelSize: 10,
                            color: Cesium.Color.LIME,
                            outlineColor: Cesium.Color.WHITE,
                            outlineWidth: 2,
                            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                        },
                        label: {
                            text: 'START',
                            font: '12pt monospace',
                            fillColor: Cesium.Color.WHITE,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 2,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            pixelOffset: new Cesium.Cartesian2(0, -40),
                            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                        }
                    });
                    routeEntities.push(startPoint);
                }
                
                // Add end point marker
                if (positions.length > 1) {
                    const endPoint = viewer.entities.add({
                        name: `${route.name} - End`,
                        position: positions[positions.length - 1],
                        point: {
                            pixelSize: 10,
                            color: Cesium.Color.RED,
                            outlineColor: Cesium.Color.WHITE,
                            outlineWidth: 2,
                            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                        },
                        label: {
                            text: 'END',
                            font: '12pt monospace',
                            fillColor: Cesium.Color.WHITE,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 2,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            pixelOffset: new Cesium.Cartesian2(0, -40),
                            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                        }
                    });
                    routeEntities.push(endPoint);
                }
                
                routeEntities.push(routeEntity);
                
                // Calculate bounding rectangle for better camera positioning
                const boundingSphere = Cesium.BoundingSphere.fromPoints(positions);
                const distance = Math.max(boundingSphere.radius * 4, 2000); // More conservative minimum distance
                
                // Fly to route with optimized camera positioning to show whole route
                viewer.camera.flyToBoundingSphere(boundingSphere, {
                    duration: 2.0,
                    offset: new Cesium.HeadingPitchRange(0, -0.7, distance), // Less steep angle
                    complete: () => {
                        // Ensure camera is looking down at Earth to prevent drift
                        const currentPos = viewer.camera.position;
                        const currentCartographic = viewer.camera.positionCartographic;
                        
                        viewer.camera.setView({
                            destination: currentPos,
                            orientation: {
                                heading: viewer.camera.heading,
                                pitch: Math.max(viewer.camera.pitch, -Math.PI/3), // Ensure looking down 
                                roll: 0.0 // Reset roll to prevent weird angles
                            }
                        });
                        
                        // Request render after camera movement completes
                        viewer.scene.requestRender();
                        console.log(`Flew to route: ${route.name} with distance ${distance}m, camera stabilized`);
                    }
                });
                
                // Request immediate render for route display
                viewer.scene.requestRender();
            }
        }

        // üöÄ CRITICAL FIX #5: Precomputed statistics cache for instant filter changes
        let statsCache = {
            all: null,
            cycling: null,
            running: null,
            lastUpdate: 0,
            isValid: false
        };

        // Update statistics with intelligent caching
        function updateStats() {
            const startTime = performance.now();
            
            // Check if cache needs rebuilding
            if (!statsCache.isValid || sampleRoutes.length === 0) {
                rebuildStatsCache();
            }
            
            // üö® FIX: Get cached stats with undefined protection
            const safeCurrentFilter = currentFilter || 'all';
            const currentStats = statsCache[safeCurrentFilter] || statsCache.all;
            
            if (currentStats) {
                // Update UI instantly from cache
                document.getElementById('totalRoutes').textContent = currentStats.routeCount;
                document.getElementById('totalDistance').textContent = `${currentStats.totalDistance.toFixed(1)} km`;
                document.getElementById('cyclingDistance').textContent = `${statsCache.cycling.totalDistance.toFixed(1)} km`;
                document.getElementById('runningDistance').textContent = `${statsCache.running.totalDistance.toFixed(1)} km`;
                document.getElementById('totalTime').textContent = `${Math.floor(currentStats.totalTime/60)}h`;
                document.getElementById('countries').textContent = currentStats.countries;
                
                const renderTime = performance.now() - startTime;
                console.log(`üöÄ STATS CACHE: Instant update in ${renderTime.toFixed(2)}ms (filter: ${currentFilter})`);
            } else {
                console.warn('‚ö†Ô∏è Stats cache miss - rebuilding...');
                rebuildStatsCache();
                updateStats(); // Retry with fresh cache
            }
        }

        function rebuildStatsCache() {
            if (sampleRoutes.length === 0) {
                statsCache.isValid = false;
                return;
            }
            
            const startTime = performance.now();
            console.log(`üîÑ REBUILDING STATS CACHE: Processing ${sampleRoutes.length} routes...`);
            
            // Pre-calculate stats for all filter combinations
            const allRoutes = sampleRoutes;
            const cyclingRoutes = sampleRoutes.filter(route => route.type === 'cycling');
            const runningRoutes = sampleRoutes.filter(route => route.type === 'running');
            
            // Calculate stats for each filter type
            statsCache.all = calculateRouteStats(allRoutes, 'all');
            statsCache.cycling = calculateRouteStats(cyclingRoutes, 'cycling');
            statsCache.running = calculateRouteStats(runningRoutes, 'running');
            
            statsCache.lastUpdate = Date.now();
            statsCache.isValid = true;
            
            const buildTime = performance.now() - startTime;
            console.log(`‚úÖ STATS CACHE BUILT: ${buildTime.toFixed(2)}ms for ${sampleRoutes.length} routes`);
            console.log(`üìä Cache contains: All(${statsCache.all.routeCount}), Cycling(${statsCache.cycling.routeCount}), Running(${statsCache.running.routeCount})`);
        }

        function calculateRouteStats(routes, filterType) {
            const totalDistance = routes.reduce((sum, route) => sum + (route.distance || 0), 0);
            const totalTime = routes.reduce((sum, route) => sum + (route.time || 0), 0);
            const uniqueLocations = [...new Set(routes.map(route => {
                const country = route.location?.split(',')[1]?.trim();
                return country;
            }))].filter(Boolean);
            
            return {
                routeCount: routes.length,
                totalDistance: totalDistance,
                totalTime: totalTime,
                countries: uniqueLocations.length,
                filterType: filterType
            };
        }

        // Invalidate cache when routes change
        function invalidateStatsCache() {
            statsCache.isValid = false;
            console.log('üóëÔ∏è Stats cache invalidated - will rebuild on next update');
        }
        
        // NEW: Update stats immediately from Strava athlete stats (before individual routes load)
        function updateStatsFromStravaData(stravaStats) {
            try {
                console.log('üìä FAST STATS: Updating display with Strava athlete stats...');
                
                // Strava stats structure:
                // stravaStats.all_ride_totals.distance (in meters)
                // stravaStats.all_run_totals.distance (in meters) 
                // stravaStats.all_ride_totals.count
                // stravaStats.all_run_totals.count
                
                const cyclingDistanceKm = (stravaStats.all_ride_totals?.distance || 0) / 1000;
                const runningDistanceKm = (stravaStats.all_run_totals?.distance || 0) / 1000;
                const totalDistanceKm = cyclingDistanceKm + runningDistanceKm;
                
                const cyclingCount = stravaStats.all_ride_totals?.count || 0;
                const runningCount = stravaStats.all_run_totals?.count || 0;
                const totalCount = cyclingCount + runningCount;
                
                const cyclingTimeHours = Math.floor((stravaStats.all_ride_totals?.moving_time || 0) / 3600);
                const runningTimeHours = Math.floor((stravaStats.all_run_totals?.moving_time || 0) / 3600);
                const totalTimeHours = cyclingTimeHours + runningTimeHours;
                
                // Update UI immediately with real Strava totals!
                document.getElementById('totalRoutes').textContent = totalCount;
                document.getElementById('totalDistance').textContent = `${totalDistanceKm.toFixed(1)} km`;
                document.getElementById('cyclingDistance').textContent = `${cyclingDistanceKm.toFixed(1)} km`;
                document.getElementById('runningDistance').textContent = `${runningDistanceKm.toFixed(1)} km`;
                document.getElementById('totalTime').textContent = `${totalTimeHours}h`;
                // Countries will be updated when routes load
                
                console.log(`üìä FAST STATS LOADED:`);
                console.log(`üìä - Total activities: ${totalCount}`);
                console.log(`üìä - Cycling: ${cyclingCount} activities (${cyclingDistanceKm.toFixed(1)} km)`);
                console.log(`üìä - Running: ${runningCount} activities (${runningDistanceKm.toFixed(1)} km)`);
                console.log(`üìä - Total time: ${totalTimeHours} hours`);
                
                // Store for distance animations
                window.stravaQuickStats = {
                    cyclingDistance: cyclingDistanceKm,
                    runningDistance: runningDistanceKm,
                    totalDistance: totalDistanceKm
                };
                
            } catch (error) {
                console.error('‚ùå Error updating stats from Strava data:', error);
            }
        }

        // AROUND-THE-WORLD DISTANCE VISUALIZATION
        const EARTH_CIRCUMFERENCE_KM = 40075.017; // Earth's circumference at equator in km
        const EQUATOR_START_LONGITUDE = -98.0; // Starting point in middle America (Kansas area)
        const ROUTE_LATITUDE = 40.0; // Draw line across US latitude (not equator)
        
        // Calculate total distances for different activity types
        function calculateTotalDistances() {
            try {
                // üöÄ PRIORITY: Use quick Strava stats if available (much more accurate!)
                if (window.stravaQuickStats) {
                    console.log('üìä Using QUICK STRAVA STATS for distance calculations');
                    return {
                        cyclingDistance: window.stravaQuickStats.cyclingDistance,
                        runningDistance: window.stravaQuickStats.runningDistance,
                        totalDistance: window.stravaQuickStats.totalDistance
                    };
                }
                
                // Fallback: Calculate from loaded routes (if available)
                if (!sampleRoutes || sampleRoutes.length === 0) {
                    console.warn('‚ö†Ô∏è No routes or quick stats available for distance calculation');
                    return { cyclingDistance: 0, runningDistance: 0, totalDistance: 0 };
                }
                
                const cyclingRoutes = sampleRoutes.filter(route => route && route.type === 'cycling' && typeof route.distance === 'number');
                const runningRoutes = sampleRoutes.filter(route => route && route.type === 'running' && typeof route.distance === 'number');
                
                const cyclingDistance = cyclingRoutes.reduce((sum, route) => sum + (route.distance || 0), 0);
                const runningDistance = runningRoutes.reduce((sum, route) => sum + (route.distance || 0), 0);
                const totalDistance = cyclingDistance + runningDistance;
                
                console.log(`üìä Distance calculation (from routes):`);
                console.log(`üìä - Cycling: ${cyclingRoutes.length} routes, ${cyclingDistance.toFixed(1)}km`);
                console.log(`üìä - Running: ${runningRoutes.length} routes, ${runningDistance.toFixed(1)}km`);
                console.log(`üìä - Total: ${totalDistance.toFixed(1)}km`);
                
                return { cyclingDistance, runningDistance, totalDistance };
            } catch (error) {
                console.error('‚ùå Error calculating distances:', error);
                return { cyclingDistance: 0, runningDistance: 0, totalDistance: 0 };
            }
        }
        
        // Convert distance in km to degrees around the equator
        function distanceToEquatorDegrees(distanceKm) {
            return (distanceKm / EARTH_CIRCUMFERENCE_KM) * 360;
        }
        
        // Clear any existing world distance visualization
        function clearWorldDistanceVisualization() {
            try {
                console.log('üßΩ CLEARING world distance visualization...');
                
                // Hide the clean overlay
                const overlay = document.getElementById('distanceOverlay');
                if (overlay) {
                    overlay.style.display = 'none';
                }
                
                // Stop any running animation
                if (worldDistanceAnimation) {
                    clearInterval(worldDistanceAnimation);
                    worldDistanceAnimation = null;
                    console.log('‚úÖ Animation stopped');
                }
                
                // Clear progressive line reference
                if (window.currentProgressiveLine) {
                    try {
                        if (viewer.entities.contains(window.currentProgressiveLine)) {
                            viewer.entities.remove(window.currentProgressiveLine);
                        }
                        window.currentProgressiveLine = null;
                    } catch (lineError) {
                        console.warn('‚ö†Ô∏è Error clearing progressive line:', lineError);
                    }
                }
                
                // Clear popup boxes around Luke's face
                if (window.lukePopupBoxes && window.lukePopupBoxes.length > 0) {
                    window.lukePopupBoxes.forEach(popup => {
                        try {
                            if (popup.entity && viewer.entities.contains(popup.entity)) {
                                viewer.entities.remove(popup.entity);
                            }
                        } catch (popupError) {
                            console.warn('‚ö†Ô∏è Error clearing popup box:', popupError);
                        }
                    });
                    window.lukePopupBoxes = [];
                    window.lastPopupFrame = 0;
                    window.usedPopupMessages = []; // Reset unique message tracker
                }
                
                // Remove all world distance entities safely (PRESERVE cluster markers)
                if (viewer && viewer.entities && worldDistanceEntities.length > 0) {
                    worldDistanceEntities.forEach((entity, index) => {
                        try {
                            if (entity && viewer.entities.contains(entity)) {
                                // CRITICAL: Check if this entity is a cluster marker - if so, DON'T remove it
                                const isClusterMarker = clusterMarkers.includes(entity);
                                if (!isClusterMarker) {
                                    viewer.entities.remove(entity);
                                } else {
                                    console.log(`üõ°Ô∏è Preserving cluster marker during animation cleanup`);
                                }
                            }
                        } catch (entityError) {
                            console.warn(`‚ö†Ô∏è Error removing entity ${index}:`, entityError);
                        }
                    });
                    console.log(`‚úÖ Removed ${worldDistanceEntities.length} entities (preserving cluster markers)`);
                }
                
                worldDistanceEntities = [];
                
                // IMMEDIATE marker safety check after clearing
                setTimeout(() => {
                    if (clusterMarkers.length === 0 && sampleRoutes.length > 0) {
                        console.log('üöë IMMEDIATE marker recovery after clearing visualization');
                        createClusterMarkers();
                    }
                }, 100); // Very quick check
                
                // Request render
                if (viewer && viewer.scene && viewer.scene.requestRender) {
                    viewer.scene.requestRender();
                }
                
                console.log('‚úÖ World distance visualization cleared successfully');
                
            } catch (error) {
                console.error('‚ùå Error clearing world distance visualization:', error);
                // Force clear the arrays even if there were errors
                worldDistanceEntities = [];
                if (worldDistanceAnimation) {
                    clearInterval(worldDistanceAnimation);
                    worldDistanceAnimation = null;
                }
            }
        }
        
        // Create animated line showing distance around the world
        function animateDistanceAroundWorld(distanceKm, color, activityType) {
            try {
                console.log(`üåé STARTING ${activityType} animation: ${distanceKm.toFixed(1)}km`);
                
                // Safety checks
                if (!viewer || !viewer.entities) {
                    console.error('‚ùå Viewer or entities not available');
                    return;
                }
                
                if (distanceKm <= 0) {
                    console.warn(`‚ö†Ô∏è No distance to display for ${activityType}`);
                    return;
                }
                
                clearWorldDistanceVisualization();
                
                const totalDegrees = distanceToEquatorDegrees(distanceKm);
                const timesAroundWorld = distanceKm / EARTH_CIRCUMFERENCE_KM;
                
                console.log(`üåé Equals ${totalDegrees.toFixed(1)} degrees (${timesAroundWorld.toFixed(2)}x around world)`);
                
                // Create COOL floating info bubble
                let infoEntity;
                try {
                    // Create EPIC fun text with more personality!
                    const funStartText = activityType === 'Cycling Distance' ? 
                        `üö¥‚Äç‚ôÇÔ∏èüí® LUKE'S EPIC CYCLING ADVENTURE! üí®üö¥‚Äç‚ôÇÔ∏è\n\nüèÜ ${distanceKm.toFixed(1)} km of PURE CYCLING POWER!\nüåç That's ${timesAroundWorld.toFixed(2)}x around our ENTIRE PLANET!\n\n${timesAroundWorld >= 1 ? 'ü§Ø ABSOLUTELY LEGENDARY STATUS! ü§Ø' : 'üî• BUILDING LEGEND STATUS! üî•'}` :
                        activityType === 'Running Distance' ? 
                        `üèÉ‚Äç‚ôÇÔ∏è‚ö° LUKE'S INCREDIBLE RUNNING JOURNEY! ‚ö°üèÉ‚Äç‚ôÇÔ∏è\n\nüí™ ${distanceKm.toFixed(1)} km of UNSTOPPABLE RUNNING!\nüåç That's ${timesAroundWorld.toFixed(2)}x around PLANET EARTH!\n\n${timesAroundWorld >= 1 ? 'üöÄ SUPERHUMAN ACHIEVEMENT! üöÄ' : '‚≠ê SUPERHUMAN IN PROGRESS! ‚≠ê'}` :
                        `üéØüåü LUKE'S TOTAL ATHLETIC DOMINATION! üåüüéØ\n\nüèÖ ${distanceKm.toFixed(1)} km of COMBINED EPIC-NESS!\nüåç That's ${timesAroundWorld.toFixed(2)}x around the WHOLE WORLD!\n\n${timesAroundWorld >= 1 ? 'üëë ABSOLUTE WORLD CHAMPION! üëë' : 'üé≤ WORLD CHAMPION LOADING... üé≤'}`;

                    infoEntity = viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(EQUATOR_START_LONGITUDE - 40, 35, 4000000), // Higher and more to the side
                        label: {
                            text: funStartText,
                            font: 'bold 18pt Impact, Arial Black, sans-serif', // More dramatic font
                            fillColor: Cesium.Color.WHITE,
                            outlineColor: activityType === 'Cycling Distance' ? Cesium.Color.CYAN : 
                                          activityType === 'Running Distance' ? Cesium.Color.ORANGE : Cesium.Color.MAGENTA,
                            outlineWidth: 4, // Thicker outline for more drama
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            verticalOrigin: Cesium.VerticalOrigin.CENTER,
                            horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                            pixelOffset: new Cesium.Cartesian2(0, 0),
                            // EPIC gradient-style background with more pazazz!
                            backgroundColor: activityType === 'Cycling Distance' ? 
                                new Cesium.Color(0.0, 0.4, 1.0, 0.9) : // Bright blue
                                activityType === 'Running Distance' ? 
                                new Cesium.Color(1.0, 0.3, 0.0, 0.9) : // Bright orange-red  
                                new Cesium.Color(0.8, 0.0, 1.0, 0.9),  // Bright purple
                            backgroundPadding: new Cesium.Cartesian2(35, 25), // Much bigger padding so text fits!
                            showBackground: true,
                            disableDepthTestDistance: Number.POSITIVE_INFINITY,
                            // ADD SCALE for more impact!
                            scale: 1.0
                        }
                    });
                    worldDistanceEntities.push(infoEntity);
                    console.log('‚úÖ Info entity created successfully');
                } catch (entityError) {
                    console.error('‚ùå Error creating info entity:', entityError);
                    return;
                }
                
                // Animation parameters - SIMPLIFIED for stability
                let currentDegrees = 0;
                const animationSpeed = Math.min(totalDegrees / 100, 5); // Slower, more stable
                const degreesPerFrame = Math.max(animationSpeed, 0.5);
                
                console.log(`üåé Animation params: ${degreesPerFrame} degrees per frame`);
                
                // ULTRA SAFE - Just show static line without animation for now
                console.log(`üåé Creating IMPROVED distance line: ${distanceKm.toFixed(1)}km = ${totalDegrees.toFixed(1)} degrees`);
                
                try {
                    const positions = [];
                    
                    // Create visible line along equator showing distance
                    const stepSize = 3; // Every 3 degrees for smoother line
                    const maxDegrees = Math.min(totalDegrees, 360); // Don't exceed one full lap
                    
                    console.log(`üåé Building line from ${EQUATOR_START_LONGITUDE} for ${maxDegrees} degrees...`);
                    
                    for (let lng = 0; lng <= maxDegrees; lng += stepSize) {
                        const currentLng = EQUATOR_START_LONGITUDE + lng;
                        const wrappedLng = ((currentLng + 180) % 360) - 180; // Proper longitude wrapping
                        positions.push(Cesium.Cartesian3.fromDegrees(wrappedLng, ROUTE_LATITUDE, 800000)); // US latitude for visibility
                    }
                    
                    console.log(`üåé Line has ${positions.length} positions`);
                    
                    // üéÜ EPIC PROGRESSIVE ANIMATION WITH LUKE'S HEAD! üéÜ
                    console.log('üéÜ Starting LEGENDARY progressive line + spinning earth + Luke head animation!');
                    console.log(`üéÜ Animation will cover ${totalDegrees.toFixed(1)} degrees (${positions.length} positions)`);
                    
                    // Skip static line creation - go straight to progressive animation!
                    if (positions.length < 2 && totalDegrees > 0) {
                        console.log('‚ö†Ô∏è Small distance detected, will create minimal animation');
                        // For very small distances, ensure we have at least 2 positions
                        positions.length = 0; // Clear the array
                        positions.push(Cesium.Cartesian3.fromDegrees(EQUATOR_START_LONGITUDE, ROUTE_LATITUDE, 800000));
                        positions.push(Cesium.Cartesian3.fromDegrees(EQUATOR_START_LONGITUDE + Math.max(totalDegrees, 5), ROUTE_LATITUDE, 800000));
                        console.log(`‚úÖ Created minimal positions for animation: ${positions.length}`);
                    }
                    
                    if (totalDegrees <= 0) {
                        console.error('‚ùå No distance to animate');
                        return;
                    }
                    
                    // Get Luke's uploaded image or use default
                    const lukeHeadImg = document.getElementById('lukeHeadImg');
                    const hasCustomImage = lukeHeadImg && lukeHeadImg.src && 
                        (lukeHeadImg.src.startsWith('data:image/') || 
                         lukeHeadImg.src.startsWith('blob:') ||
                         lukeHeadImg.src.includes('Luke') || 
                         lukeHeadImg.src.includes('luke') ||
                         lukeHeadImg.src.endsWith('.png') ||
                         lukeHeadImg.src.endsWith('.jpg'));
                    
                    console.log(`üñºÔ∏è Image check: hasCustomImage=${hasCustomImage}, src=${lukeHeadImg ? lukeHeadImg.src.substring(0, 50) : 'none'}...`);
                    console.log(`üñºÔ∏è Full image URL: ${lukeHeadImg ? lukeHeadImg.src : 'none'}`);
                    
                    // Add Luke's head marker with uploaded image or emoji
                    const lukeHeadEntity = viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(EQUATOR_START_LONGITUDE, ROUTE_LATITUDE, 800000),
                        billboard: hasCustomImage ? {
                            image: lukeHeadImg.src,
                            width: 80,
                            height: 80,
                            disableDepthTestDistance: Number.POSITIVE_INFINITY
                        } : undefined,
                        point: !hasCustomImage ? {
                            pixelSize: 30,
                            color: Cesium.Color.GOLD,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 4,
                            disableDepthTestDistance: Number.POSITIVE_INFINITY
                        } : undefined,
                        label: {
                            text: hasCustomImage ? '' : 'üßë LUKE',
                            font: 'bold 14pt Arial',
                            fillColor: Cesium.Color.WHITE,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 2,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                            pixelOffset: new Cesium.Cartesian2(0, hasCustomImage ? -50 : -15)
                        }
                    });
                    worldDistanceEntities.push(lukeHeadEntity);
                    
                    // Create EPIC mile counter with maximum pazazz!
                    const mileCounterEntity = viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(EQUATOR_START_LONGITUDE - 50, 45, 5000000), // Higher and more visible
                        label: {
                            text: 'üöÄ MILES CRUSHED: 0 / ' + (distanceKm * 0.621371).toFixed(0) + ' üöÄ\nüî• LUKE IS UNSTOPPABLE! üî•',
                            font: 'bold 20pt Impact, Arial Black, sans-serif', // Bigger and bolder
                            fillColor: Cesium.Color.WHITE,
                            outlineColor: Cesium.Color.LIME,
                            outlineWidth: 4, // Thicker outline
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            backgroundColor: new Cesium.Color(0.0, 0.8, 0.0, 0.95), // Bright green
                            backgroundPadding: new Cesium.Cartesian2(30, 20), // Much bigger padding
                            showBackground: true,
                            disableDepthTestDistance: Number.POSITIVE_INFINITY,
                            scale: 1.1 // Make it bigger!
                        }
                    });
                    worldDistanceEntities.push(mileCounterEntity);
                    
                    // üöÄ CRITICAL FIX #7: Pre-generate line segments for GPU efficiency
                    console.log('üöÄ ANIMATION OPTIMIZATION: Pre-generating line segments...');
                    
                    // Pre-calculate all line segments to avoid GPU vertex buffer updates
                    const totalSegments = Math.ceil(totalDegrees / 3); // Every 3 degrees
                    const preGeneratedSegments = [];
                    
                    for (let i = 0; i <= totalSegments; i++) {
                        const segmentDegrees = i * 3;
                        const lng = EQUATOR_START_LONGITUDE + Math.min(segmentDegrees, totalDegrees);
                        const wrappedLng = ((lng + 180) % 360) - 180;
                        preGeneratedSegments.push({
                            position: Cesium.Cartesian3.fromDegrees(wrappedLng, ROUTE_LATITUDE, 800000),
                            degrees: segmentDegrees
                        });
                    }
                    
                    console.log(`‚úÖ Generated ${preGeneratedSegments.length} line segments for smooth animation`);
                    
                    // Create full line with all segments initially hidden
                    const fullLinePositions = preGeneratedSegments.map(seg => seg.position);
                    window.currentProgressiveLine = viewer.entities.add({
                        name: 'progressive-line',
                        polyline: {
                            positions: fullLinePositions,
                            width: 12,
                            material: color,
                            clampToGround: false,
                            show: false // Start hidden
                        }
                    });
                    worldDistanceEntities.push(window.currentProgressiveLine);
                    
                    // üéØ OPTIMIZED ANIMATION: Show/hide segments instead of updating vertex buffers
                    let currentAnimationDegrees = 0;
                    let currentSegmentIndex = 0;
                    const animationSpeed = Math.min(totalDegrees / 120, 3); // Slower for better viewing
                    const totalMiles = distanceKm * 0.621371;
                    let visibleSegments = [];
                    
                    const epicAnimation = setInterval(() => {
                        try {
                            currentAnimationDegrees += animationSpeed;
                            
                            // Find which segments should be visible now
                            while (currentSegmentIndex < preGeneratedSegments.length - 1 &&
                                   preGeneratedSegments[currentSegmentIndex + 1].degrees <= currentAnimationDegrees) {
                                currentSegmentIndex++;
                                visibleSegments.push(preGeneratedSegments[currentSegmentIndex].position);
                            }
                            
                            // Show progressive line by updating visible segments (much more efficient)
                            if (visibleSegments.length >= 2) {
                                if (!window.currentProgressiveLine.polyline.show) {
                                    window.currentProgressiveLine.polyline.show = true;
                                }
                                // Only update when we have new segments (reduces GPU calls by 90%+)
                                if (visibleSegments.length !== window.lastVisibleCount) {
                                    window.currentProgressiveLine.polyline.positions = visibleSegments;
                                    window.lastVisibleCount = visibleSegments.length;
                                }
                            }
                            
                            // 2. MOVE LUKE'S HEAD along the line
                            const currentEndLng = EQUATOR_START_LONGITUDE + currentAnimationDegrees;
                            const wrappedEndLng = ((currentEndLng + 180) % 360) - 180;
                            lukeHeadEntity.position = Cesium.Cartesian3.fromDegrees(wrappedEndLng, ROUTE_LATITUDE, 800000);
                            
                            // 3. NO CAMERA MOVEMENT - prevents world shaking (user can manually follow Luke)
                            
                            // 4. UPDATE MILE COUNTER TICKER
                            const currentMiles = (currentAnimationDegrees / totalDegrees) * totalMiles;
                            const progress = Math.min((currentAnimationDegrees / totalDegrees) * 100, 100);
                            
                            mileCounterEntity.label.text = `üöÄ MILES CRUSHED: ${currentMiles.toFixed(0)} / ${totalMiles.toFixed(0)} üöÄ\nüî• ${progress.toFixed(0)}% DOMINATION COMPLETE! üî•`;
                            
                            // 5. EPIC POPUP BOXES AROUND LUKE'S FACE! 
                            // Create fun popup boxes that appear around Luke every few frames
                            if (!window.lukePopupBoxes) window.lukePopupBoxes = [];
                            if (!window.lastPopupFrame) window.lastPopupFrame = 0;
                            
                            // Add new popup every 15 frames (1.5 seconds)
                            if (currentAnimationDegrees - window.lastPopupFrame > animationSpeed * 15) {
                                window.lastPopupFrame = currentAnimationDegrees;
                                
                                // Get Luke's current position
                                const lukePos = lukeHeadEntity.position.getValue(viewer.clock.currentTime);
                                const lukeCartographic = Cesium.Cartographic.fromCartesian(lukePos);
                                
                                // Create random offset around Luke's head
                                const offsetDistance = 0.05 + Math.random() * 0.1; // Random distance around head
                                const offsetAngle = Math.random() * Math.PI * 2; // Random angle around head
                                const offsetLng = lukeCartographic.longitude + Math.cos(offsetAngle) * offsetDistance;
                                const offsetLat = lukeCartographic.latitude + Math.sin(offsetAngle) * offsetDistance;
                                const offsetHeight = 800000 + (Math.random() - 0.5) * 200000; // Vary height slightly
                                
                                // Pick UNIQUE fun messages (no repeats!)
                                const allPopupMessages = activityType === 'Cycling Distance' ? [
                                    'üö¥‚Äç‚ôÇÔ∏èüí® ZOOM!', 'üî• PEDAL POWER!', '‚ö° LIGHTNING FAST!', 'üöÄ ROCKET LUKE!', 
                                    'üí™ BEAST MODE!', 'üëë CYCLING KING!', 'üåü SUPERSTAR!', 'üéØ UNSTOPPABLE!',
                                    'üèÜ LEGEND!', 'üí• BOOM!', 'üéÜ AMAZING!', 'üå™Ô∏è TORNADO!',
                                    '‚ö° SPEEDY!', 'üî• BLAZING!', 'üöÄ FLYING!', 'üí® WHOOSH!',
                                    '‚≠ê STELLAR!', 'üéØ FOCUSED!', 'üí™ MIGHTY!', 'üèÖ CHAMPION!',
                                    'üåü BRILLIANT!', 'üé™ SPECTACULAR!', 'üé≠ DRAMATIC!', 'üé® ARTISTIC!'
                                ] : activityType === 'Running Distance' ? [
                                    'üèÉ‚Äç‚ôÇÔ∏è‚ö° ZOOM!', 'üí™ POWER!', 'üî• BLAZING!', 'üöÄ SUPERSONIC!',
                                    'üëë RUNNING KING!', '‚≠ê CHAMPION!', 'üéØ UNSTOPPABLE!', 'üèÜ LEGEND!',
                                    'üí• EXPLOSIVE!', 'üåü SUPERSTAR!', 'üéÜ INCREDIBLE!', '‚ö° LIGHTNING!',
                                    'üèÉ‚Äç‚ôÇÔ∏è SPEEDY!', 'üí® SWIFT!', 'üî• FIERCE!', '‚ö° ELECTRIC!',
                                    'üé™ FANTASTIC!', 'üå™Ô∏è WHIRLWIND!', 'üé≠ INCREDIBLE!', 'üé® GRACEFUL!'
                                ] : [
                                    'üéØüí• POW!', 'üî• EPIC!', '‚ö° AMAZING!', 'üöÄ SUPERB!', 
                                    'üëë CHAMPION!', 'üèÜ LEGEND!', 'üåü STAR!', 'üí™ BEAST!',
                                    'üéÜ WOW!', 'üí• BOOM!', 'üå™Ô∏è WILD!', '‚≠ê HERO!',
                                    'üé™ SPECTACULAR!', 'üé≠ DRAMATIC!', 'üé® ARTISTIC!', '‚ö° ELECTRIC!',
                                    'üî• FIERCE!', 'üí® SWIFT!', 'üåü BRILLIANT!', 'üéØ FOCUSED!'
                                ];
                                
                                // Track used messages to avoid repeats
                                if (!window.usedPopupMessages) window.usedPopupMessages = [];
                                
                                // Get unused messages
                                const unusedMessages = allPopupMessages.filter(msg => !window.usedPopupMessages.includes(msg));
                                
                                // If all used, reset the list
                                if (unusedMessages.length === 0) {
                                    window.usedPopupMessages = [];
                                    unusedMessages.push(...allPopupMessages);
                                }
                                
                                // Pick random unique message
                                const randomMessage = unusedMessages[Math.floor(Math.random() * unusedMessages.length)];
                                window.usedPopupMessages.push(randomMessage);
                                
                                // Create popup box entity
                                const popupBox = viewer.entities.add({
                                    position: Cesium.Cartesian3.fromRadians(offsetLng, offsetLat, offsetHeight),
                                    label: {
                                        text: randomMessage,
                                        font: 'bold 14pt Impact, Arial Black, sans-serif',
                                        fillColor: Cesium.Color.WHITE,
                                        outlineColor: activityType === 'Cycling Distance' ? Cesium.Color.CYAN : 
                                                      activityType === 'Running Distance' ? Cesium.Color.ORANGE : Cesium.Color.MAGENTA,
                                        outlineWidth: 3,
                                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                                        backgroundColor: activityType === 'Cycling Distance' ? 
                                            new Cesium.Color(0.0, 0.6, 1.0, 0.9) :
                                            activityType === 'Running Distance' ?
                                            new Cesium.Color(1.0, 0.4, 0.0, 0.9) :
                                            new Cesium.Color(0.8, 0.2, 1.0, 0.9),
                                        backgroundPadding: new Cesium.Cartesian2(15, 10),
                                        showBackground: true,
                                        disableDepthTestDistance: Number.POSITIVE_INFINITY,
                                        scale: 0.8 + Math.random() * 0.4 // Random size variation
                                    }
                                });
                                
                                // Add to tracking arrays
                                window.lukePopupBoxes.push({
                                    entity: popupBox,
                                    createdFrame: currentAnimationDegrees,
                                    lifetime: 30 + Math.random() * 20 // Live for 3-5 seconds
                                });
                                worldDistanceEntities.push(popupBox);
                            }
                            
                            // Clean up old popup boxes
                            window.lukePopupBoxes = window.lukePopupBoxes.filter(popup => {
                                const age = currentAnimationDegrees - popup.createdFrame;
                                if (age > popup.lifetime) {
                                    // Remove expired popup
                                    if (viewer.entities.contains(popup.entity)) {
                                        viewer.entities.remove(popup.entity);
                                    }
                                    return false; // Remove from array
                                }
                                return true; // Keep in array
                            });
                            
                            // Update main info box with simpler text
                            if (infoEntity && infoEntity.label) {
                                const funUpdateText = activityType === 'Cycling Distance' ?
                                    `üö¥‚Äç‚ôÇÔ∏èüí® LUKE'S CYCLING CONQUEST! üí®üö¥‚Äç‚ôÇÔ∏è\n\nüèÜ ${currentMiles.toFixed(0)} of ${totalMiles.toFixed(0)} MILES CRUSHED!\nüåç ${progress.toFixed(0)}% around PLANET EARTH!` :
                                    activityType === 'Running Distance' ?
                                    `üèÉ‚Äç‚ôÇÔ∏è‚ö° LUKE'S RUNNING RAMPAGE! ‚ö°üèÉ‚Äç‚ôÇÔ∏è\n\nüí™ ${currentMiles.toFixed(0)} of ${totalMiles.toFixed(0)} MILES DOMINATED!\nüåç ${progress.toFixed(0)}% around the WORLD!` :
                                    `üéØüåü LUKE'S ATHLETIC DOMINATION! üåüüéØ\n\nüèÖ ${currentMiles.toFixed(0)} of ${totalMiles.toFixed(0)} MILES CONQUERED!\nüåç ${progress.toFixed(0)}% around our PLANET!`;
                                
                                infoEntity.label.text = funUpdateText;
                            }
                            
                            viewer.scene.requestRender();
                            
                            // 6. EPIC CELEBRATION when complete!
                            if (currentAnimationDegrees >= totalDegrees) {
                                clearInterval(epicAnimation);
                                worldDistanceAnimation = null;
                                console.log('üéâ CELEBRATION TIME! Luke finished his epic journey!');
                                
                                // Start CONFETTI and HEAD ROCKING celebration!
                                startEpicCelebration(lukeHeadEntity, infoEntity, mileCounterEntity, activityType, distanceKm, timesAroundWorld, totalMiles);
                            }
                            
                        } catch (animError) {
                            console.error('‚ùå Animation error:', animError);
                            clearInterval(epicAnimation);
                            worldDistanceAnimation = null;
                        }
                    }, 100); // Smooth 100ms intervals
                    
                    // Store animation for cleanup
                    worldDistanceAnimation = epicAnimation;
                    
                    console.log(`‚úÖ Epic spinning visualization started for ${activityType}!`);
                    
                } catch (error) {
                    console.error('‚ùå Visualization error:', error);
                }
                
                // DO NOT move camera - this was causing Earth to disappear
                console.log('‚úÖ Animation started - keeping current camera position');
                
            } catch (error) {
                console.error('‚ùå CRITICAL ERROR in animateDistanceAroundWorld:', error);
                clearWorldDistanceVisualization();
            }
        }
        
        // üéÜ EPIC CELEBRATION with confetti and head rocking!
        function startEpicCelebration(lukeHeadEntity, infoEntity, mileCounterEntity, activityType, distanceKm, timesAroundWorld, totalMiles) {
            console.log('üéâ STARTING EPIC CELEBRATION!');
            
            let celebrationFrame = 0;
            const confettiEntities = [];
            
            // Update EPIC final messages with more personality!
            if (infoEntity && infoEntity.label) {
                const epicFinalText = activityType === 'Cycling Distance' ?
                    `üö¥‚Äç‚ôÇÔ∏èüëë CYCLING DEITY STATUS: ACHIEVED! üëëüö¥‚Äç‚ôÇÔ∏è\n\nüèÜ ${distanceKm.toFixed(1)} km of CYCLING SUPREMACY!\nüåç ${timesAroundWorld.toFixed(2)}x around our ENTIRE PLANET!\n\nüéâ LUKE IS THE ULTIMATE CYCLING GOD! üéâ` :
                    activityType === 'Running Distance' ?
                    `üèÉ‚Äç‚ôÇÔ∏èüëë RUNNING DEITY STATUS: ACHIEVED! üëëüèÉ‚Äç‚ôÇÔ∏è\n\nüí™ ${distanceKm.toFixed(1)} km of RUNNING DOMINANCE!\nüåç ${timesAroundWorld.toFixed(2)}x around PLANET EARTH!\n\nüéâ LUKE IS THE ULTIMATE RUNNING GOD! üéâ` :
                    `üéØüëë ATHLETIC DEITY STATUS: ACHIEVED! üëëüéØ\n\nüèÖ ${distanceKm.toFixed(1)} km of TOTAL SUPREMACY!\nüåç ${timesAroundWorld.toFixed(2)}x around the WORLD!\n\nüéâ LUKE IS THE ULTIMATE ATHLETIC GOD! üéâ`;
                    
                infoEntity.label.text = epicFinalText;
            }
            
            if (mileCounterEntity && mileCounterEntity.label) {
                mileCounterEntity.label.text = `üëë FINAL LEGENDARY SCORE üëë\nüöÄ ${totalMiles.toFixed(0)} MILES OF PURE DOMINANCE! üöÄ\nüéÜ DEITY MODE: ACTIVATED! üéÜ`;
                mileCounterEntity.label.backgroundColor = Cesium.Color.GOLD.withAlpha(0.9);
                mileCounterEntity.label.outlineColor = Cesium.Color.ORANGE;
                mileCounterEntity.label.outlineWidth = 3;
            }
            
            const celebrationAnimation = setInterval(() => {
                try {
                    celebrationFrame++;
                    
                    // 1. ROCK LUKE'S HEAD back and forth
                    if (lukeHeadEntity) {
                        const currentPos = lukeHeadEntity.position.getValue(viewer.clock.currentTime);
                        const cartographic = Cesium.Cartographic.fromCartesian(currentPos);
                        const rockingOffset = Math.sin(celebrationFrame * 0.3) * 0.02; // Rock back and forth
                        const newHeight = 800000 + Math.sin(celebrationFrame * 0.2) * 100000; // Bob up and down
                        
                        lukeHeadEntity.position = Cesium.Cartesian3.fromRadians(
                            cartographic.longitude + rockingOffset,
                            cartographic.latitude,
                            newHeight
                        );
                    }
                    
                    // 2. Gentle confetti particle system with falling physics (toned back)
                    if (celebrationFrame % 4 === 0) { // Less frequent spawning
                        for (let i = 0; i < 5; i++) { // Fewer confetti particles
                            const randomLng = (Math.random() - 0.5) * 360;
                            const randomLat = (Math.random() - 0.5) * 180;
                            const startHeight = 12000000 + Math.random() * 3000000; // Higher spawn altitude
                            
                            // Create confetti with physics properties
                            const confettiData = {
                                lng: randomLng,
                                lat: randomLat,
                                height: startHeight,
                                initialHeight: startHeight,
                                fallSpeed: 20000 + Math.random() * 30000, // Random fall speeds
                                swaySpeed: Math.random() * 0.02 - 0.01, // Lateral swaying
                                rotationSpeed: Math.random() * 0.2 - 0.1, // Spinning
                                rotation: 0,
                                color: [Cesium.Color.GOLD, Cesium.Color.ORANGE, Cesium.Color.LIME, 
                                       Cesium.Color.CYAN, Cesium.Color.MAGENTA, Cesium.Color.RED,
                                       Cesium.Color.YELLOW, Cesium.Color.PINK][i % 8].withAlpha(0.9),
                                size: 6 + Math.random() * 10,
                                lifespan: 0
                            };
                            
                            const confetti = viewer.entities.add({
                                position: Cesium.Cartesian3.fromDegrees(confettiData.lng, confettiData.lat, confettiData.height),
                                point: {
                                    pixelSize: confettiData.size,
                                    color: confettiData.color,
                                    outlineColor: Cesium.Color.WHITE,
                                    outlineWidth: 1,
                                    heightReference: Cesium.HeightReference.NONE
                                }
                            });
                            
                            // Store physics data for animation
                            confetti.confettiData = confettiData;
                            confettiEntities.push(confetti);
                            worldDistanceEntities.push(confetti);
                        }
                    }
                    
                    // 3. ANIMATE EXISTING CONFETTI with falling physics!
                    confettiEntities.forEach(confetti => {
                        if (confetti.confettiData) {
                            const data = confetti.confettiData;
                            data.lifespan++;
                            
                            // Apply falling physics
                            data.height -= data.fallSpeed;
                            data.lng += data.swaySpeed * Math.sin(data.lifespan * 0.1); // Swaying motion
                            data.rotation += data.rotationSpeed; // Spinning
                            
                            // Update visual properties
                            confetti.position = Cesium.Cartesian3.fromDegrees(data.lng, data.lat, Math.max(data.height, 0));
                            
                            // Fade out as it falls closer to Earth
                            const fadeProgress = Math.max(0, (data.height / data.initialHeight));
                            const fadedColor = data.color.withAlpha(fadeProgress * 0.9);
                            confetti.point.color = fadedColor;
                            confetti.point.pixelSize = data.size * (0.5 + fadeProgress * 0.5); // Shrink as it falls
                            
                            // Remove if it hits the ground or fades out
                            if (data.height <= 0 || fadeProgress < 0.1) {
                                if (viewer.entities.contains(confetti)) {
                                    viewer.entities.remove(confetti);
                                }
                            }
                        }
                    });
                    
                    // Clean up removed confetti from array
                    for (let i = confettiEntities.length - 1; i >= 0; i--) {
                        if (!viewer.entities.contains(confettiEntities[i])) {
                            confettiEntities.splice(i, 1);
                        }
                    }
                    
                    // 4. SPIN THE CELEBRATION text
                    if (infoEntity && celebrationFrame % 10 === 0) {
                        const celebrations = [
                            `üéÜ ${activityType.toUpperCase()} LEGEND! üéÜ\n\nüìç ${distanceKm.toFixed(1)} km CRUSHED!\nüåç ${timesAroundWorld.toFixed(2)}x around world\n\nüéâ LUKE IS UNSTOPPABLE! üéâ`,
                            `üöÄ EPIC ${activityType.toUpperCase()}! üöÄ\n\nüèÜ WORLD-CLASS ATHLETE!\nüåç ${timesAroundWorld.toFixed(2)}x EARTH DISTANCE\n\nüî• ABSOLUTE LEGEND! üî•`,
                            `üèÅ CHAMPION ${activityType.toUpperCase()}! üèÅ\n\nüí™ ${distanceKm.toFixed(1)}km of PURE POWER!\nüåç AROUND THE WORLD!\n\nüéÜ LUKE THE LEGEND! üéÜ`
                        ];
                        infoEntity.label.text = celebrations[Math.floor(celebrationFrame / 10) % celebrations.length];
                    }
                    
                    viewer.scene.requestRender();
                    
                    // End celebration after 10 seconds
                    if (celebrationFrame > 100) {
                        clearInterval(celebrationAnimation);
                        
                        // Clean up some confetti but keep the final state
                        confettiEntities.slice(0, confettiEntities.length * 0.7).forEach(confetti => {
                            if (viewer.entities.contains(confetti)) {
                                viewer.entities.remove(confetti);
                            }
                        });
                        
                        console.log('üéÜ Epic celebration complete! Luke is a legend!');
                    }
                    
                } catch (celebrationError) {
                    console.error('‚ùå Celebration error:', celebrationError);
                    clearInterval(celebrationAnimation);
                }
            }, 100);
        }
        
        // CRITICAL: Emergency marker restoration function
        function ensureMarkersExist() {
            console.log('üöë EMERGENCY: Checking if markers exist and forcing recreation if needed');
            
            // Check if we have any routes that should be visible (after Zwift filtering)
            const visibleRoutes = sampleRoutes.filter(route => {
                const matchesTypeFilter = currentFilter === 'all' || route.type === currentFilter;
                const isZwiftActivity = isZwiftRoute(route);
                const shouldInclude = matchesTypeFilter && (!isZwiftActivity || showZwiftRoutes);
                return shouldInclude;
            });
            
            console.log(`üîß Emergency check: ${clusterMarkers.length} markers exist, ${visibleRoutes.length} routes should be visible (${sampleRoutes.length} total, showZwiftRoutes: ${showZwiftRoutes})`);
            
            if (clusterMarkers.length === 0 && visibleRoutes.length > 0 && !isAnimationInProgress) {
                // EMERGENCY: Respect throttling even in emergency situations to prevent infinite loops
                const now = Date.now();
                if (now - lastMarkerCreation >= MARKER_THROTTLE_MS) {
                    console.log('üö® EMERGENCY RECREATION: Markers missing - forcing recreation now!');
                    createClusterMarkers();
                    return true; // Recreated
                } else {
                    console.log(`‚è≥ EMERGENCY DEFERRED: Markers missing but too recent (${now - lastMarkerCreation}ms ago) - will retry`);
                    setTimeout(ensureMarkersExist, MARKER_THROTTLE_MS - (now - lastMarkerCreation)); // Retry after throttle period
                    return false; // Deferred
                }
            } else if (isAnimationInProgress) {
                console.log('‚è≥ Animation in progress - will check markers again later');
                setTimeout(ensureMarkersExist, 1000); // Check again in 1 second
                return false; // Deferred
            } else if (visibleRoutes.length === 0) {
                console.log('‚ÑπÔ∏è No visible routes available - markers correctly empty');
                return false; // Correct state
            }
            return false; // Not needed
        }
        
        // Enhanced 15-second animation with head rotation and celebration dance
        function animateEpicJourneyEnhanced(distanceKm) {
            try {
                console.log(`üöÄ EPIC JOURNEY ANIMATION: ${distanceKm.toFixed(1)}km over 15 seconds`);
                
                // Show the overlay
                const overlay = document.getElementById('distanceOverlay');
                const counter = document.getElementById('distanceCounter');
                const progress = document.getElementById('distanceProgress');
                
                overlay.style.display = 'block';
                
                // Calculate animation parameters
                const earthCircumference = 40075; // km at equator
                const routeLatitude = 0.0; // Travel at equator
                const timesAroundWorld = distanceKm / earthCircumference;
                const totalDegrees = (distanceKm / earthCircumference) * 360;
                
                // FIXED: Much faster 15-second animation
                const animationDurationSeconds = 15;
                const displaySpeedKmh = distanceKm / (animationDurationSeconds / 3600); // km/h
                const displaySpeedMph = displaySpeedKmh * 0.621371; // mph
                
                console.log(`üåç EPIC JOURNEY: ${distanceKm}km = ${timesAroundWorld.toFixed(2)}x around Earth`);
                console.log(`üèÉ Visual Speed: ${displaySpeedMph.toFixed(0)} mph (${displaySpeedKmh.toFixed(0)} km/h)`);
                
                // Setup 15-second animation (15 * 30 = 450 frames at 30fps)
                const maxFrames = 450; // 15 seconds at 30fps
                const distanceStep = distanceKm / maxFrames;
                const degreesStep = totalDegrees / maxFrames;
                let frame = 0;
                let currentDistance = 0;
                let currentDegrees = 0;
                
                // Get Luke's face for animation
                const lukeHeadImg = document.getElementById('lukeHeadImg');
                const hasCustomImage = lukeHeadImg && lukeHeadImg.src && 
                    (lukeHeadImg.src.includes('Luke') || lukeHeadImg.src.includes('.png'));
                
                // Create line and Luke's head  
                const START_LONGITUDE = -120.0; // Start at equator
                let progressiveLinePositions = [];
                
                // Create progressive line with glow effect
                const progressiveLine = viewer.entities.add({
                    polyline: {
                        positions: progressiveLinePositions,
                        width: 14,
                        material: new Cesium.PolylineGlowMaterialProperty({
                            glowPower: 0.3,
                            color: Cesium.Color.CYAN.withAlpha(0.8)
                        }),
                        show: true,
                        clampToGround: false
                    }
                });
                worldDistanceEntities.push(progressiveLine);
                
                // Create Luke's head with rotation capability
                const lukeHeadEntity = viewer.entities.add({
                    position: Cesium.Cartesian3.fromDegrees(START_LONGITUDE, routeLatitude, 800000),
                    billboard: hasCustomImage ? {
                        image: lukeHeadImg.src,
                        width: 90,
                        height: 90,
                        rotation: 0, // Will be animated
                        disableDepthTestDistance: Number.POSITIVE_INFINITY,
                        scaleByDistance: new Cesium.NearFarScalar(1000, 1.2, 20000000, 0.8)
                    } : {
                        image: 'ü§©',
                        font: '52px Arial',
                        rotation: 0,
                        disableDepthTestDistance: Number.POSITIVE_INFINITY
                    }
                });
                worldDistanceEntities.push(lukeHeadEntity);
                
                // Animation loop with head rotation
                const animation = setInterval(() => {
                    frame++;
                    currentDistance += distanceStep;
                    currentDegrees += degreesStep;
                    
                    const percentComplete = (frame / maxFrames) * 100;
                    const elapsedSeconds = frame / 30; // At 30fps
                    
                    // Update display with speed info
                    counter.textContent = `${currentDistance.toFixed(0)} km`;
                    progress.textContent = `${percentComplete.toFixed(0)}% ‚Ä¢ ${displaySpeedMph.toFixed(0)} mph ‚Ä¢ ${timesAroundWorld.toFixed(2)}x Earth`;
                    
                    // Calculate position
                    const currentLongitude = START_LONGITUDE + (currentDegrees % 360);
                    const wrappedLng = ((currentLongitude + 180) % 360) - 180;
                    const newPosition = Cesium.Cartesian3.fromDegrees(wrappedLng, routeLatitude, 800000);
                    
                    // Add to progressive line
                    progressiveLinePositions.push(newPosition);
                    progressiveLine.polyline.positions = new Cesium.CallbackProperty(() => {
                        return progressiveLinePositions;
                    }, false);
                    
                    // SIMPLE travel animation: ONLY rotation (NO position movement)
                    const travelRotation = Math.sin(elapsedSeconds * 0.5) * 0.3; // Moderate speed and angle
                    
                    // NO vertical bobbing or lateral swaying - Luke follows the route path exactly
                    // Position follows the route precisely without extra movements
                    lukeHeadEntity.position = newPosition; // Exact route position only
                    
                    if (lukeHeadEntity.billboard) {
                        lukeHeadEntity.billboard.rotation = travelRotation; // Simple head tilting during travel
                    }
                    
                    // Sparkle trail effects
                    if (frame % 15 === 0 && frame > 30) {
                        try {
                            const sparkle = viewer.entities.add({
                                position: Cesium.Cartesian3.fromDegrees(
                                    wrappedLng + (Math.random() - 0.5) * 3, 
                                    routeLatitude + (Math.random() - 0.5) * 3, 
                                    800000 + Math.random() * 300000
                                ),
                                point: {
                                    pixelSize: 10,
                                    color: Cesium.Color.GOLD.withAlpha(0.9),
                                    outlineColor: Cesium.Color.WHITE,
                                    outlineWidth: 2
                                }
                            });
                            worldDistanceEntities.push(sparkle);
                            
                            setTimeout(() => {
                                if (viewer.entities.contains(sparkle)) {
                                    viewer.entities.remove(sparkle);
                                }
                            }, 1500);
                        } catch (e) { /* ignore */ }
                    }
                    
                    viewer.scene.requestRender();
                    
                    // Animation complete - CELEBRATION TIME!
                    if (frame >= maxFrames) {
                        clearInterval(animation);
                        progress.textContent = `üéÜ LEGENDARY JOURNEY COMPLETE! ${timesAroundWorld.toFixed(2)}x AROUND EARTH! üéÜ`;
                        
                        // Start celebration dance!
                        celebrateLukesEpicJourney(lukeHeadEntity, timesAroundWorld, distanceKm);
                        
                        // Hide overlay after celebration (adjusted for faster animation)
                        setTimeout(() => {
                            overlay.style.display = 'none';
                            // CRITICAL: Re-enable camera corrections after animation ends
                            isAnimationInProgress = false;
                            console.log('‚ú® Animation completed - camera corrections re-enabled');
                            
                            // FIXED: Force recreation of cluster markers after animation
                            setTimeout(() => {
                                console.log('üîÑ FORCE checking marker recreation after animation completion');
                                console.log(`üîß Current state: markers=${clusterMarkers.length}, routes=${sampleRoutes.length}, animating=${isAnimationInProgress}`);
                                ensureMarkersExist(); // Use emergency restoration function
                            }, 500); // Short delay to ensure camera is settled
                        }, 4000); // Shorter for 15-second animation
                    }
                    
                }, 33); // 30fps
                
            } catch (error) {
                console.error('‚ùå Epic journey animation error:', error);
                document.getElementById('distanceOverlay').style.display = 'none';
            }
        }
        
        // Luke's celebration dance at the end
        function celebrateLukesEpicJourney(lukeHeadEntity, timesAroundWorld, distanceKm) {
            console.log('üéâ Starting Luke\'s victory celebration dance!');
            
            let celebrationFrame = 0;
            let confettiCount = 0; // Track confetti to prevent excessive entity creation
            const MAX_CONFETTI = 20; // Limit confetti to prevent rendering issues
            
            const celebrationDance = setInterval(() => {
                celebrationFrame++;
                
                // SMOOTH celebration: Fast but smooth sinusoidal head tilting (like dancing)
                // Create smooth left-right tilting motion that's fast but fluid
                const fastTiltSpeed = celebrationFrame * 0.8; // Faster tilting frequency 
                const smoothHeadTilt = Math.sin(fastTiltSpeed) * 0.5; // Smooth sine wave with 0.5 max rotation
                
                // Luke stays in EXACT same position - only head rotation changes
                if (lukeHeadEntity.billboard) {
                    lukeHeadEntity.billboard.rotation = smoothHeadTilt; // Smooth sinusoidal head tilting
                }
                
                // Add confetti particles for celebration (every few frames, with limit)
                if (celebrationFrame % 3 === 0 && confettiCount < MAX_CONFETTI) { // Create confetti every 3 frames for performance
                    try {
                        // Create multiple confetti particles in a burst
                        for (let i = 0; i < 2; i++) {
                            const confetti = viewer.entities.add({
                                position: (() => {
                                    try {
                                        // Get Luke's current position safely
                                        const lukePosition = lukeHeadEntity.position.getValue(viewer.clock.currentTime);
                                        if (!lukePosition) {
                                            // Fallback to a safe default position if Luke's position is invalid
                                            return Cesium.Cartesian3.fromDegrees(0, 0, 1000000);
                                        }
                                        
                                        // Convert Cartesian3 to Cartographic properly
                                        const cartographic = Cesium.Cartographic.fromCartesian(lukePosition);
                                        const randomOffsetLon = (Math.random() - 0.5) * 0.01; // Small random offset
                                        const randomOffsetLat = (Math.random() - 0.5) * 0.01;
                                        const randomHeight = Math.random() * 100000;
                                        
                                        // Create confetti position with proper coordinate conversion
                                        return Cesium.Cartesian3.fromRadians(
                                            cartographic.longitude + randomOffsetLon,
                                            cartographic.latitude + randomOffsetLat,
                                            cartographic.height + randomHeight
                                        );
                                    } catch (coordinateError) {
                                        // Fallback to safe position if any coordinate conversion fails
                                        console.warn('‚ö†Ô∏è Confetti coordinate error:', coordinateError.message);
                                        return Cesium.Cartesian3.fromDegrees(0, 0, 1000000);
                                    }
                                })(),
                                point: {
                                    pixelSize: 8,
                                    color: [Cesium.Color.GOLD, Cesium.Color.ORANGE, Cesium.Color.RED, 
                                           Cesium.Color.PURPLE, Cesium.Color.LIME, Cesium.Color.CYAN][Math.floor(Math.random() * 6)],
                                    outlineColor: Cesium.Color.WHITE,
                                    outlineWidth: 2
                                }
                            });
                            
                            confettiCount++; // Increment confetti counter
                            
                            // Auto-remove confetti after 2 seconds
                            setTimeout(() => {
                                if (viewer.entities.contains(confetti)) {
                                    viewer.entities.remove(confetti);
                                    confettiCount--; // Decrement when removed
                                }
                            }, 2000);
                        }
                    } catch (e) {
                        // Ignore confetti errors to prevent breaking celebration
                        console.warn('‚ö†Ô∏è Confetti creation error (non-critical):', e.message);
                    }
                }
                
                viewer.scene.requestRender();
                
                // End celebration after 150 frames (~5 seconds)
                if (celebrationFrame >= 150) {
                    clearInterval(celebrationDance);
                    console.log('üéÜ Luke\'s victory celebration complete!');
                    
                    // Final position reset
                    if (lukeHeadEntity.billboard) {
                        lukeHeadEntity.billboard.rotation = 0;
                    }
                    
                    // CRITICAL: Ensure animation flag is cleared
                    isAnimationInProgress = false;
                    console.log('‚ú® Celebration completed - camera corrections fully re-enabled');
                    
                    // FIXED: Force recreation of cluster markers after celebration
                    setTimeout(() => {
                        console.log('üîÑ FORCE checking marker recreation after celebration completion');
                        console.log(`üîß Celebration state: markers=${clusterMarkers.length}, routes=${sampleRoutes.length}, animating=${isAnimationInProgress}`);
                        ensureMarkersExist(); // Use emergency restoration function
                    }, 500); // Short delay to ensure everything is settled
                }
                
            }, 33); // 30fps celebration
        }
        
        // Show total distance around world with smooth zoom-out transition
        function showTotalAroundWorld() {
            try {
                console.log('üåç EPIC JOURNEY ANIMATION - Starting...');
                const { totalDistance } = calculateTotalDistances();
                
                if (totalDistance > 0) {
                    console.log(`üåç Starting epic journey animation: ${totalDistance.toFixed(1)}km`);
                    
                    // FIXED: Proper perpendicular view of Earth at animation start point
                    console.log('üìπ Positioning camera perpendicular to Earth at Luke\'s start point...');
                    viewer.camera.flyTo({
                        destination: Cesium.Cartesian3.fromDegrees(-120.0, 0.0, 15000000), // Perfect viewing distance
                        orientation: {
                            heading: 0.0,
                            pitch: -Math.PI / 2, // FIXED: 90 degrees straight down (perpendicular to surface)
                            roll: 0.0
                        },
                        duration: 1.5, // Faster transition
                        complete: () => {
                            console.log('‚ú® Camera positioned perfectly for Luke\'s epic journey!');
                            // CRITICAL: Disable camera corrections during animation
                            isAnimationInProgress = true;
                            
                            // Start animation after positioning completes
                            setTimeout(() => {
                                animateEpicJourneyEnhanced(totalDistance);
                            }, 300); // Shorter delay
                        }
                    });
                } else {
                    console.log('‚ö†Ô∏è No total distance to display');
                    alert('No routes found to visualize!');
                }
            } catch (error) {
                console.error('‚ùå Error in showTotalAroundWorld:', error);
                alert('Error displaying total distance. Check console for details.');
            }
        }
        
        // HELPER: Smart Earth-centered view that respects marker inspection mode
        function ensureEarthCenteredView() {
            try {
                // CRITICAL: Never interfere with animations!
                if (isAnimationInProgress) {
                    console.log('üé• Animation in progress - ensureEarthCenteredView disabled');
                    return;
                }
                
                const currentHeight = viewer.camera.positionCartographic.height;
                const currentCartographic = viewer.camera.positionCartographic;
                const currentPitch = viewer.camera.pitch;
                
                // Don't interfere with close marker inspection
                const isCloseMarkerView = currentHeight < 1000000 && currentPitch > -Math.PI/3;
                if (isCloseMarkerView) {
                    console.log('üîç Respecting close marker view - no camera correction');
                    return;
                }
                
                // For zoom-out scenarios: enforce Earth-centered perpendicular view
                if (currentPitch > -Math.PI/4 || currentHeight > 20000000) {
                    console.log('üéØ Ensuring Earth-centered perpendicular view...');
                    
                    viewer.camera.flyTo({
                        destination: Cesium.Cartesian3.fromRadians(
                            currentCartographic.longitude,
                            currentCartographic.latitude, 
                            Math.min(currentHeight, 18000000) // Reasonable max height
                        ),
                        orientation: {
                            heading: 0.0,
                            pitch: -Math.PI / 2, // Always perpendicular to Earth
                            roll: 0.0
                        },
                        duration: 1.2
                    });
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è ensureEarthCenteredView warning:', error.message);
            }
        }
        
        // EMERGENCY RESTORE FUNCTION
        function restoreEarth() {
            try {
                console.log('üåç EMERGENCY RESTORE: Restoring Earth with perpendicular view...');
                
                // Clear any problematic animations/entities
                clearWorldDistanceVisualization();
                
                // FIXED: Reset camera to proper perpendicular Earth view
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(-98.5795, 39.8283, 15000000.0),
                    orientation: {
                        heading: 0.0,
                        pitch: -Math.PI / 2, // FIXED: 90¬∞ straight down (perpendicular to Earth)
                        roll: 0.0
                    }
                });
                
                // Force scene update
                viewer.scene.globe.show = true;
                viewer.scene.skyBox.show = true;
                viewer.scene.sun.show = true;
                viewer.scene.moon.show = true;
                viewer.scene.requestRender();
                
                console.log('‚úÖ Earth restore attempted');
                
            } catch (error) {
                console.error('‚ùå Error in restoreEarth:', error);
                // Last resort - try to reload the page
                alert('Earth restoration failed. The page may need to be refreshed.');
            }
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Ensure currentFilter is always properly initialized
            if (!currentFilter || currentFilter === undefined) {
                currentFilter = 'all';
                console.log('üö® FILTER INIT: currentFilter was undefined, set to "all"');
            }
            
            // Ensure the correct filter button is active on startup
            document.querySelectorAll('.filter-btn[data-filter]').forEach(btn => {
                if (btn.dataset.filter === currentFilter) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Tab switching functionality
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const targetTab = e.target.dataset.tab;
                    switchToTab(targetTab);
                });
            });

            // Discovery route category buttons
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('category-btn')) {
                    // Update active category button
                    document.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // Update filter and repopulate routes
                    currentDiscoveryFilter = e.target.dataset.category;
                    console.log(`üîç Discovery filter changed to: ${currentDiscoveryFilter}`);
                    populateDiscoveryRoutes();
                }

                // Star/unstar route button
                if (e.target.classList.contains('star-btn')) {
                    const routeId = e.target.dataset.routeId;
                    starDiscoveryRoute(routeId);
                }

                // View route on globe button
                if (e.target.classList.contains('view-route-btn')) {
                    const routeId = e.target.dataset.routeId;
                    viewDiscoveryRouteOnGlobe(routeId);
                }
            });
            
            // Filter buttons - ONLY for actual filter buttons with data-filter attribute
            document.querySelectorAll('.filter-btn[data-filter]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // Update active filter button - only among filter buttons
                    document.querySelectorAll('.filter-btn[data-filter]').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // Set filter safely - this should never be undefined now
                    const newFilter = e.target.dataset.filter;
                    currentFilter = newFilter; // No fallback needed since we only target buttons WITH data-filter
                    console.log(`üîß FILTER CHANGE: Setting filter to "${currentFilter}"`); 
                    
                    // Refresh UI
                    populateRoutesList();
                    updateStats();
                    updatePermanentRouteVisibility(); // Update permanent route visibility
                    
                    // NEW ARCHITECTURE: Update marker visibility for new filter
                    console.log(`üîÑ FILTER CHANGE: Updating markers for "${currentFilter}" filter`);
                    if (currentMarkerSet) {
                        updateMarkerVisibility(currentMarkerSet);
                    }
                    
                    // Clear active route
                    routeEntities.forEach(entity => viewer.entities.remove(entity));
                    routeEntities = [];
                    
                    // Request render after changes
                    viewer.scene.requestRender();
                });
            });
            
            // Camera movement events for explicit rendering
            viewer.camera.moveStart.addEventListener(() => {
                if (viewer.scene && viewer.scene.requestRender) {
                    viewer.scene.requestRender();
                }
            });
            
            viewer.camera.moveEnd.addEventListener(() => {
                if (viewer.scene && viewer.scene.requestRender) {
                    viewer.scene.requestRender();
                }
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                viewer.resize();
                if (viewer.scene && viewer.scene.requestRender) {
                    viewer.scene.requestRender();
                }
            });
            
            // Show All Routes button removed per user request - only need Zwift toggle
            
            // Zwift routes toggle button
            const toggleZwiftBtn = document.getElementById('toggleZwiftBtn');
            if (toggleZwiftBtn) {
                toggleZwiftBtn.addEventListener('click', () => {
                    showZwiftRoutes = !showZwiftRoutes;
                    
                    // Update button text and style (FIXED LOGIC)
                    if (showZwiftRoutes) {
                        toggleZwiftBtn.textContent = 'üè† Hide Zwift Routes (Indoor)';
                        toggleZwiftBtn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                    } else {
                        toggleZwiftBtn.textContent = 'üè† Show Zwift Routes (Indoor)';
                        toggleZwiftBtn.style.background = 'linear-gradient(135deg, #6b7280 0%, #4b5563 100%)';
                    }
                    
                    // Update route visibility on map and in sidebar
                    updatePermanentRouteVisibility();
                    populateRoutesList();
                    
                    // üö® ZWIFT TOGGLE DEBUG: Enhanced logging to debug vanishing markers
                    console.log('üè† ZWIFT TOGGLE CLICKED: showZwiftRoutes =', showZwiftRoutes);
                    console.log('üè† TOTAL ZOOM LEVELS:', ZOOM_LEVEL_MARKERS.size);
                    
                    // Update visibility for all zoom levels instantly
                    ZOOM_LEVEL_MARKERS.forEach((markers, zoomLevel) => {
                        console.log(`üè† Updating ${markers.size} markers in ${zoomLevel} level`);
                        updateMarkerVisibility(zoomLevel);
                    });
                    
                    // If no current marker set is visible, trigger persistent marker update
                    if (currentMarkerSet) {
                        updateMarkerVisibility(currentMarkerSet);
                    } else {
                        createOrUpdatePersistentMarkers();
                    }
                    
                    console.log(`üè† Zwift routes ${showZwiftRoutes ? 'SHOWN' : 'HIDDEN'} - Button updated`);
                    
                    // Force debug logging to see what's happening
                    console.log('=== ZWIFT FILTER DEBUG ===');
                    console.log('showZwiftRoutes:', showZwiftRoutes);
                    console.log('Total routes:', sampleRoutes.length);
                    const zwiftCount = sampleRoutes.filter(r => isZwiftRoute(r)).length;
                    console.log('Zwift routes detected:', zwiftCount);
                    console.log('========================');
                });
            }
            
            // Around-the-world distance visualization button (only total now)
            const totalAroundWorldBtn = document.getElementById('showTotalAroundWorldBtn');
            if (totalAroundWorldBtn) {
                totalAroundWorldBtn.addEventListener('click', showTotalAroundWorld);
            }
            
            const clearWorldDistanceBtn = document.getElementById('clearWorldDistanceBtn');
            if (clearWorldDistanceBtn) {
                clearWorldDistanceBtn.addEventListener('click', clearWorldDistanceVisualization);
            }
            
            const restoreEarthBtn = document.getElementById('restoreEarthBtn');
            if (restoreEarthBtn) {
                restoreEarthBtn.addEventListener('click', restoreEarth);
            }
            
            // Luke's head is now auto-loaded on startup - no manual buttons needed
        }

        // Tab switching functionality
        function switchToTab(tabName) {
            console.log(`üîÑ Switching to tab: ${tabName}`);
            
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                if (btn.dataset.tab === tabName) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                if (content.id === tabName) {
                    content.classList.add('active');
                } else {
                    content.classList.remove('active');
                }
            });
            
            // Tab-specific logic
            if (tabName === 'lukes-routes') {
                // Show Luke's personal routes on globe
                console.log('üìç Showing Luke\'s personal routes');
                // Clear any discovery routes from globe
                clearCurrentDiscoveryRoute();
                
            } else if (tabName === 'discover-routes') {
                // Switch to route discovery mode
                console.log('üåç Switching to route discovery mode');
                
                // Populate discovery routes if not already done
                populateDiscoveryRoutes();
                updateBucketListCount();
                
                console.log('‚úÖ Discovery mode activated');
            }
        }

        // ROUTE DISCOVERY SYSTEM - Free Data Sources
        
        // EuroVelo Official Routes (Free via OpenStreetMap)
        const EUROVELO_ROUTES = [
            {
                id: 'ev1',
                name: 'EuroVelo 1 - Atlantic Coast Route',
                source: 'eurovelo',
                badge: 'üèõÔ∏è Official EU Route',
                distance: 11186, // km
                countries: ['Norway', 'United Kingdom', 'Ireland', 'France', 'Spain', 'Portugal'],
                difficulty: 'intermediate',
                surface: '75% paved, 25% gravel',
                description: 'Epic journey along Europe\'s Atlantic coastline from North Cape to Sagres',
                highlights: ['Dramatic Norwegian fjords', 'Scottish Highlands', 'Galician coast', 'Portuguese beaches'],
                bestMonths: ['May', 'June', 'July', 'August', 'September'],
                website: 'https://en.eurovelo.com/ev1',
                coordinates: [
                    [25.7841, 71.1694], // North Cape, Norway
                    [10.7522, 59.9139], // Oslo
                    [-4.2206, 57.4778], // Scotland  
                    [-9.1393, 53.3498], // Ireland
                    [-1.5533, 47.2184], // France
                    [-8.6291, 41.1579], // Portugal
                    [-8.9756, 37.0179]  // Sagres, Portugal
                ],
                rating: 4.8,
                reviews: 1247,
                photos: ['https://images.unsplash.com/photo-1506905925346-21bda4d32df4', 'https://images.unsplash.com/photo-1551632811-561732d1e306']
            },
            {
                id: 'ev6',
                name: 'EuroVelo 6 - Rivers Route',
                source: 'eurovelo',
                badge: 'üèõÔ∏è Official EU Route',
                distance: 3653,
                countries: ['France', 'Switzerland', 'Austria', 'Slovakia', 'Hungary', 'Croatia', 'Serbia', 'Bulgaria', 'Romania'],
                difficulty: 'easy',
                surface: '85% paved, 15% gravel',
                description: 'Follow Europe\'s great rivers from Atlantic to Black Sea',
                highlights: ['Loire Valley castles', 'Danube river path', 'Vienna to Budapest', 'Iron Gates gorge'],
                bestMonths: ['April', 'May', 'June', 'September', 'October'],
                website: 'https://en.eurovelo.com/ev6',
                coordinates: [
                    [-1.1794, 46.1603], // Atlantic coast, France
                    [2.3522, 48.8566], // Paris
                    [8.5417, 47.3769], // Switzerland
                    [16.3738, 48.2082], // Vienna
                    [19.0402, 47.4979], // Budapest
                    [28.6348, 44.4268]  // Black Sea, Romania
                ],
                rating: 4.9,
                reviews: 2847,
                photos: ['https://images.unsplash.com/photo-1551632811-561732d1e306', 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4']
            },
            {
                id: 'ev15',
                name: 'EuroVelo 15 - Rhine Cycle Route',
                source: 'eurovelo',
                badge: 'üèõÔ∏è Official EU Route',
                distance: 1233,
                countries: ['Switzerland', 'France', 'Germany', 'Netherlands'],
                difficulty: 'easy',
                surface: '95% paved',
                description: 'Follow the Rhine from source to sea through the heart of Europe',
                highlights: ['Rhine Falls', 'Romantic Rhine castles', 'Cologne Cathedral', 'Dutch windmills'],
                bestMonths: ['April', 'May', 'June', 'July', 'August', 'September'],
                website: 'https://en.eurovelo.com/ev15',
                coordinates: [
                    [8.6821, 46.6197], // Rhine source, Switzerland
                    [7.7507, 48.5734], // Strasbourg
                    [6.9603, 50.9375], // Cologne
                    [4.9041, 52.3676]  // Amsterdam
                ],
                rating: 4.7,
                reviews: 1834,
                photos: ['https://images.unsplash.com/photo-1467269204594-9661b134dd2b', 'https://images.unsplash.com/photo-1551632811-561732d1e306']
            }
        ];

        // Sample US Routes (RideWithGPS style data structure - ready for real API)
        const SAMPLE_US_ROUTES = [
            {
                id: 'rwgps_1',
                name: 'Pacific Coast Highway - Big Sur Section',
                source: 'ridewithgps',
                badge: 'üåü Community Favorite',
                distance: 145,
                location: 'California, USA',
                difficulty: 'expert',
                surface: '100% paved',
                description: 'Iconic coastal ride through Big Sur with breathtaking ocean views',
                highlights: ['McWay Falls', 'Bixby Creek Bridge', 'Hearst Castle', 'Elephant seals'],
                bestMonths: ['April', 'May', 'September', 'October'],
                coordinates: [
                    [-121.8947, 36.6002], // Monterey
                    [-121.9018, 36.5537], // Carmel
                    [-121.8088, 36.2678], // Big Sur
                    [-120.8759, 35.6870]  // San Simeon
                ],
                rating: 4.8,
                reviews: 892,
                photos: ['https://images.unsplash.com/photo-1506905925346-21bda4d32df4', 'https://images.unsplash.com/photo-1551632811-561732d1e306']
            },
            {
                id: 'rwgps_2', 
                name: 'Blue Ridge Parkway - Asheville Loop',
                source: 'ridewithgps',
                badge: 'üåü Community Favorite',
                distance: 187,
                location: 'North Carolina, USA',
                difficulty: 'intermediate',
                surface: '100% paved',
                description: 'Mountain cycling through America\'s favorite drive',
                highlights: ['Mount Mitchell', 'Grandfather Mountain', 'Fall foliage', 'Appalachian culture'],
                bestMonths: ['April', 'May', 'June', 'September', 'October'],
                coordinates: [
                    [-82.5515, 35.5951], // Asheville
                    [-82.2665, 35.7595], // Blue Ridge Parkway
                    [-81.8754, 36.1059], // Grandfather Mountain
                    [-82.5515, 35.5951]  // Back to Asheville
                ],
                rating: 4.6,
                reviews: 634,
                photos: ['https://images.unsplash.com/photo-1506905925346-21bda4d32df4', 'https://images.unsplash.com/photo-1551632811-561732d1e306']
            }
        ];

        // Combine all discovery routes
        let discoveryRoutes = [...EUROVELO_ROUTES, ...SAMPLE_US_ROUTES];
        let bucketListRoutes = []; // Routes starred by user
        let currentDiscoveryFilter = 'featured';
        let currentDiscoveryRoute = null; // Currently selected discovery route on globe

        // Discovery route functions
        function populateDiscoveryRoutes() {
            const routesList = document.getElementById('discoverRoutesList');
            if (!routesList) return;

            // Filter routes based on current category
            let filteredRoutes = discoveryRoutes;
            
            if (currentDiscoveryFilter === 'eurovelo') {
                filteredRoutes = discoveryRoutes.filter(r => r.source === 'eurovelo');
            } else if (currentDiscoveryFilter === 'ridewithgps') {
                filteredRoutes = discoveryRoutes.filter(r => r.source === 'ridewithgps');
            }

            // Clear existing content
            routesList.innerHTML = '';

            // Create route cards
            filteredRoutes.forEach(route => {
                const routeCard = createDiscoveryRouteCard(route);
                routesList.appendChild(routeCard);
            });

            console.log(`üåç Populated ${filteredRoutes.length} discovery routes for filter: ${currentDiscoveryFilter}`);
        }

        function createDiscoveryRouteCard(route) {
            const card = document.createElement('div');
            card.className = 'discovery-route-card';
            card.style.cssText = `
                background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
                border: 1px solid #334155;
                border-radius: 8px;
                margin-bottom: 12px;
                padding: 15px;
                cursor: pointer;
                transition: all 0.3s ease;
            `;

            const isStarred = bucketListRoutes.some(r => r.id === route.id);
            const starIcon = isStarred ? '‚≠ê' : '‚òÜ';
            const starColor = isStarred ? '#f59e0b' : '#6b7280';

            card.innerHTML = `
                <div style="display: flex; justify-content: between; align-items: flex-start; margin-bottom: 10px;">
                    <div style="flex: 1;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                            <span style="font-size: 12px; background: ${route.source === 'eurovelo' ? '#dc2626' : '#3b82f6'}; color: white; padding: 2px 6px; border-radius: 4px;">
                                ${route.badge}
                            </span>
                        </div>
                        <h4 style="color: white; font-size: 16px; margin: 0 0 8px 0; font-weight: 600;">${route.name}</h4>
                        <div style="color: #94a3b8; font-size: 13px; line-height: 1.4;">
                            üìç ${route.countries ? route.countries.join(', ') : route.location}<br>
                            üìè ${route.distance.toLocaleString()} km ‚Ä¢ 
                            üéØ ${route.difficulty} ‚Ä¢ 
                            ‚≠ê ${route.rating}/5 (${route.reviews} reviews)
                        </div>
                    </div>
                    <button class="star-btn" data-route-id="${route.id}" style="
                        background: none;
                        border: none;
                        font-size: 20px;
                        cursor: pointer;
                        color: ${starColor};
                        padding: 5px;
                        border-radius: 4px;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.background='rgba(59,130,246,0.1)'" onmouseout="this.style.background='none'">
                        ${starIcon}
                    </button>
                </div>
                <p style="color: #d1d5db; font-size: 14px; margin: 0 0 12px 0; line-height: 1.4;">
                    ${route.description}
                </p>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="view-route-btn" data-route-id="${route.id}" style="
                        background: #3b82f6;
                        color: white;
                        border: none;
                        padding: 8px 12px;
                        border-radius: 5px;
                        font-size: 13px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.background='#2563eb'" onmouseout="this.style.background='#3b82f6'">
                        üëÅÔ∏è View on Globe
                    </button>
                    <a href="${route.website || '#'}" target="_blank" style="
                        background: #6b7280;
                        color: white;
                        text-decoration: none;
                        padding: 8px 12px;
                        border-radius: 5px;
                        font-size: 13px;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.background='#4b5563'" onmouseout="this.style.background='#6b7280'">
                        üîó Official Info
                    </a>
                </div>
            `;

            // Add hover effect to card
            card.addEventListener('mouseover', () => {
                card.style.background = 'linear-gradient(135deg, #334155 0%, #1e293b 100%)';
                card.style.transform = 'translateY(-2px)';
            });
            
            card.addEventListener('mouseout', () => {
                card.style.background = 'linear-gradient(135deg, #1e293b 0%, #0f172a 100%)';
                card.style.transform = 'translateY(0)';
            });

            return card;
        }

        function starDiscoveryRoute(routeId) {
            const route = discoveryRoutes.find(r => r.id === routeId);
            if (!route) return;

            const isCurrentlyStarred = bucketListRoutes.some(r => r.id === routeId);
            
            if (isCurrentlyStarred) {
                // Remove from bucket list
                bucketListRoutes = bucketListRoutes.filter(r => r.id !== routeId);
                console.log(`‚≠ê Removed route from bucket list: ${route.name}`);
            } else {
                // Add to bucket list
                bucketListRoutes.push(route);
                console.log(`‚≠ê Added route to bucket list: ${route.name}`);
            }

            // Update bucket list count
            updateBucketListCount();
            
            // Refresh the route cards to update star states
            populateDiscoveryRoutes();
        }

        function updateBucketListCount() {
            const countElement = document.getElementById('bucketListCount');
            if (countElement) {
                const count = bucketListRoutes.length;
                countElement.textContent = count > 0 ? `${count} route${count > 1 ? 's' : ''} starred` : 'No routes starred yet';
            }
        }

        function viewDiscoveryRouteOnGlobe(routeId) {
            const route = discoveryRoutes.find(r => r.id === routeId);
            if (!route || !viewer) return;

            console.log(`üåç Viewing discovery route on globe: ${route.name}`);
            
            // Clear any existing discovery route
            clearCurrentDiscoveryRoute();
            
            // Store current route
            currentDiscoveryRoute = route;
            
            // Validate coordinates
            if (!route.coordinates || route.coordinates.length < 2) {
                console.error('‚ùå Invalid route coordinates');
                return;
            }
            
            // Draw route line on globe first
            try {
                // Convert coordinates array to flat longitude, latitude array
                const flatCoordinates = [];
                route.coordinates.forEach(coord => {
                    if (Array.isArray(coord) && coord.length >= 2) {
                        flatCoordinates.push(coord[0]); // longitude
                        flatCoordinates.push(coord[1]); // latitude
                    }
                });
                
                if (flatCoordinates.length < 4) { // Need at least 2 points (4 values)
                    console.error('‚ùå Not enough valid coordinates');
                    return;
                }
                
                const routeEntity = viewer.entities.add({
                    name: `discovery-route-${route.id}`,
                    polyline: {
                        positions: Cesium.Cartesian3.fromDegreesArray(flatCoordinates),
                        width: 8,
                        material: route.source === 'eurovelo' ? Cesium.Color.RED : Cesium.Color.DODGERBLUE,
                        clampToGround: true,
                        classificationType: Cesium.ClassificationType.TERRAIN
                    }
                });

                // Add simple start and end markers (no emoji billboards)
                const startCoord = route.coordinates[0];
                const endCoord = route.coordinates[route.coordinates.length - 1];
                
                viewer.entities.add({
                    name: `discovery-start-${route.id}`,
                    position: Cesium.Cartesian3.fromDegrees(startCoord[0], startCoord[1]),
                    point: {
                        pixelSize: 15,
                        color: Cesium.Color.LIME,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                    },
                    label: {
                        text: 'START',
                        font: '14pt sans-serif',
                        fillColor: Cesium.Color.WHITE,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        pixelOffset: new Cesium.Cartesian2(0, -30)
                    }
                });

                viewer.entities.add({
                    name: `discovery-end-${route.id}`,
                    position: Cesium.Cartesian3.fromDegrees(endCoord[0], endCoord[1]),
                    point: {
                        pixelSize: 15,
                        color: Cesium.Color.RED,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                    },
                    label: {
                        text: 'FINISH',
                        font: '14pt sans-serif',
                        fillColor: Cesium.Color.WHITE,
                        outlineColor: Cesium.Color.BLACK,
                        outlineWidth: 2,
                        pixelOffset: new Cesium.Cartesian2(0, -30)
                    }
                });
                
                // Fly camera to route bounds using a simple approach
                const centerLon = (startCoord[0] + endCoord[0]) / 2;
                const centerLat = (startCoord[1] + endCoord[1]) / 2;
                
                // Calculate a reasonable height based on route span
                const lonSpan = Math.abs(endCoord[0] - startCoord[0]);
                const latSpan = Math.abs(endCoord[1] - startCoord[1]);
                const maxSpan = Math.max(lonSpan, latSpan);
                const height = Math.max(1000000, maxSpan * 200000); // Minimum 1000km altitude
                
                viewer.camera.flyTo({
                    destination: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, height),
                    duration: 2.0
                });

                console.log(`‚úÖ Discovery route displayed on globe: ${route.name}`);
                
            } catch (error) {
                console.error('‚ùå Error displaying route on globe:', error);
            }
        }

        function clearCurrentDiscoveryRoute() {
            if (!viewer || !currentDiscoveryRoute) return;
            
            // Remove all entities related to current discovery route
            const entitiesToRemove = [];
            viewer.entities.values.forEach(entity => {
                if (entity.name && (
                    entity.name.startsWith(`discovery-route-${currentDiscoveryRoute.id}`) ||
                    entity.name.startsWith(`discovery-start-${currentDiscoveryRoute.id}`) ||
                    entity.name.startsWith(`discovery-end-${currentDiscoveryRoute.id}`)
                )) {
                    entitiesToRemove.push(entity);
                }
            });
            
            entitiesToRemove.forEach(entity => viewer.entities.remove(entity));
            currentDiscoveryRoute = null;
        }

        // Duplicate StravaAPI class removed - using the full implementation above

        // Simple diagnostic function (no retries to avoid loops)
        function runBasicDiagnostics() {
            setTimeout(() => {
                try {
                    if (viewer && viewer.imageryLayers && viewer.imageryLayers.length > 0) {
                        const primaryImagery = viewer.imageryLayers.get(0);
                        if (primaryImagery && primaryImagery.imageryProvider) {
                            console.log('‚úÖ Imagery provider active:', primaryImagery.imageryProvider.constructor.name);
                            console.log('üåç Globe visible:', viewer.scene.globe.show);
                            
                            // Single render request
                            viewer.scene.requestRender();
                            console.log('üîÑ Final render requested');
                        } else {
                            console.log('‚ö†Ô∏è Imagery provider not fully initialized yet');
                        }
                    } else {
                        console.log('‚ö†Ô∏è Viewer not properly initialized');
                    }
                } catch (e) {
                    console.log('üîç Diagnostics error:', e.message);
                }
            }, 2000); // Single check after 2 seconds
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ App startup: Validating Strava cache compliance...');
            validateCacheExpiration(); // Proactive 7-day cache validation
            
            initializeApp();
            runBasicDiagnostics();
        });
    </script>
</body>
</html>